{"version":3,"sources":["../../src/notifications/notifications.service.ts"],"sourcesContent":["import { Injectable, Inject, Logger, BadRequestException } from '@nestjs/common';\nimport { Expo, ExpoPushMessage, ExpoPushTicket } from 'expo-server-sdk';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport { pushTokens, notifications, NewPushToken, NewNotification } from '../database/schema/notifications';\nimport { eq, and, desc, sql } from 'drizzle-orm';\nimport { NotificationType } from './dto/notification.dto';\n\n@Injectable()\nexport class NotificationsService {\n  private readonly logger = new Logger(NotificationsService.name);\n  private expo: Expo;\n\n  constructor(@Inject(DATABASE_CONNECTION) private readonly db: any) {\n    this.expo = new Expo();\n    this.logger.log('‚úÖ Expo Push Notification service initialized');\n  }\n\n  /**\n   * Register or update a push token for a user\n   */\n  async registerPushToken(\n    userId: string,\n    token: string,\n    deviceInfo?: { platform?: string; deviceName?: string }\n  ) {\n    try {\n      // Validate token format\n      if (!Expo.isExpoPushToken(token)) {\n        throw new BadRequestException('Invalid Expo push token format');\n      }\n\n      // Check if token already exists\n      const existing = await this.db\n        .select()\n        .from(pushTokens)\n        .where(eq(pushTokens.token, token))\n        .limit(1);\n\n      if (existing.length > 0) {\n        // Update existing token\n        await this.db\n          .update(pushTokens)\n          .set({\n            userId,\n            isActive: true,\n            lastUsedAt: new Date(),\n            updatedAt: new Date(),\n            deviceType: deviceInfo?.platform || existing[0].deviceType,\n            deviceName: deviceInfo?.deviceName || existing[0].deviceName,\n          })\n          .where(eq(pushTokens.token, token));\n\n        this.logger.log(`‚úÖ Updated push token for user ${userId}`);\n      } else {\n        // Insert new token\n        const newToken: NewPushToken = {\n          userId,\n          token,\n          deviceType: deviceInfo?.platform,\n          deviceName: deviceInfo?.deviceName,\n          isActive: true,\n        };\n\n        await this.db.insert(pushTokens).values(newToken);\n        this.logger.log(`‚úÖ Registered new push token for user ${userId}`);\n      }\n\n      return { success: true, message: 'Push token registered successfully' };\n    } catch (error) {\n      this.logger.error(`‚ùå Error registering push token: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Send a notification to a single user\n   */\n  async sendNotification(\n    userId: string,\n    title: string,\n    body: string,\n    data?: any,\n    type?: NotificationType\n  ) {\n    try {\n      // Save notification to database\n      const newNotification: NewNotification = {\n        userId,\n        title,\n        body,\n        data: data ? JSON.parse(JSON.stringify(data)) : null,\n        type,\n      };\n\n      const [notification] = await this.db\n        .insert(notifications)\n        .values(newNotification)\n        .returning();\n\n      this.logger.log(`üìù Notification saved to database: ${notification.id}`);\n\n      // Get user's active push tokens\n      const tokens = await this.db\n        .select()\n        .from(pushTokens)\n        .where(and(\n          eq(pushTokens.userId, userId),\n          eq(pushTokens.isActive, true)\n        ));\n\n      if (tokens.length === 0) {\n        this.logger.warn(`‚ö†Ô∏è No active push tokens for user ${userId}`);\n        return {\n          success: true,\n          sent: false,\n          reason: 'No active push tokens',\n          notificationId: notification.id,\n        };\n      }\n\n      // Filter valid tokens\n      const validTokens = tokens.filter(t => Expo.isExpoPushToken(t.token));\n\n      if (validTokens.length === 0) {\n        this.logger.warn(`‚ö†Ô∏è No valid push tokens for user ${userId}`);\n        return {\n          success: true,\n          sent: false,\n          reason: 'No valid push tokens',\n          notificationId: notification.id,\n        };\n      }\n\n      // Prepare push messages\n      const messages: ExpoPushMessage[] = validTokens.map(t => ({\n        to: t.token,\n        sound: 'default',\n        title,\n        body,\n        data: { ...data, notificationId: notification.id },\n        priority: 'high',\n        channelId: type || 'default',\n      }));\n\n      // Send notifications in chunks\n      const chunks = this.expo.chunkPushNotifications(messages);\n      const tickets: ExpoPushTicket[] = [];\n\n      for (const chunk of chunks) {\n        try {\n          const ticketChunk = await this.expo.sendPushNotificationsAsync(chunk);\n          tickets.push(...ticketChunk);\n          this.logger.log(`üì§ Sent ${chunk.length} notifications`);\n        } catch (error) {\n          this.logger.error(`‚ùå Error sending push notification chunk: ${error.message}`);\n        }\n      }\n\n      // Update notification as sent\n      await this.db\n        .update(notifications)\n        .set({\n          pushSent: true,\n          pushSentAt: new Date(),\n        })\n        .where(eq(notifications.id, notification.id));\n\n      // Update last used timestamp for tokens\n      for (const token of validTokens) {\n        await this.db\n          .update(pushTokens)\n          .set({ lastUsedAt: new Date() })\n          .where(eq(pushTokens.id, token.id));\n      }\n\n      // Check for errors in tickets\n      const errors = tickets.filter(ticket => ticket.status === 'error');\n      if (errors.length > 0) {\n        this.logger.warn(`‚ö†Ô∏è ${errors.length} notifications failed to send`);\n        errors.forEach(error => {\n          this.logger.error(`Error: ${JSON.stringify(error)}`);\n        });\n      }\n\n      this.logger.log(`‚úÖ Notification sent successfully to user ${userId}`);\n\n      return {\n        success: true,\n        sent: true,\n        notificationId: notification.id,\n        tickets,\n      };\n    } catch (error) {\n      this.logger.error(`‚ùå Error sending notification: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Send notifications to multiple users\n   */\n  async sendBulkNotifications(\n    userIds: string[],\n    title: string,\n    body: string,\n    data?: any,\n    type?: NotificationType\n  ) {\n    try {\n      this.logger.log(`üì§ Sending bulk notifications to ${userIds.length} users`);\n\n      const results = await Promise.allSettled(\n        userIds.map(userId => this.sendNotification(userId, title, body, data, type))\n      );\n\n      const successful = results.filter(r => r.status === 'fulfilled').length;\n      const failed = results.filter(r => r.status === 'rejected').length;\n\n      this.logger.log(`‚úÖ Bulk send complete: ${successful} successful, ${failed} failed`);\n\n      return {\n        success: true,\n        total: userIds.length,\n        successful,\n        failed,\n        results,\n      };\n    } catch (error) {\n      this.logger.error(`‚ùå Error sending bulk notifications: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get notifications for a user\n   */\n  async getUserNotifications(userId: string, limit = 50, offset = 0) {\n    try {\n      const userNotifications = await this.db\n        .select()\n        .from(notifications)\n        .where(eq(notifications.userId, userId))\n        .orderBy(desc(notifications.sentAt))\n        .limit(limit)\n        .offset(offset);\n\n      const total = await this.db\n        .select({ count: sql<number>`count(*)` })\n        .from(notifications)\n        .where(eq(notifications.userId, userId));\n\n      return {\n        notifications: userNotifications,\n        total: Number(total[0]?.count || 0),\n        limit,\n        offset,\n      };\n    } catch (error) {\n      this.logger.error(`‚ùå Error getting user notifications: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get unread notification count for a user\n   */\n  async getUnreadCount(userId: string): Promise<number> {\n    try {\n      const result = await this.db\n        .select({ count: sql<number>`count(*)` })\n        .from(notifications)\n        .where(and(\n          eq(notifications.userId, userId),\n          eq(notifications.isRead, false)\n        ));\n\n      return Number(result[0]?.count || 0);\n    } catch (error) {\n      this.logger.error(`‚ùå Error getting unread count: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Mark a notification as read\n   */\n  async markAsRead(notificationId: string, userId: string) {\n    try {\n      const result = await this.db\n        .update(notifications)\n        .set({\n          isRead: true,\n          readAt: new Date(),\n        })\n        .where(and(\n          eq(notifications.id, notificationId),\n          eq(notifications.userId, userId)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        throw new BadRequestException('Notification not found or access denied');\n      }\n\n      this.logger.log(`‚úÖ Notification ${notificationId} marked as read`);\n\n      return { success: true, message: 'Notification marked as read' };\n    } catch (error) {\n      this.logger.error(`‚ùå Error marking notification as read: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Mark all notifications as read for a user\n   */\n  async markAllAsRead(userId: string) {\n    try {\n      await this.db\n        .update(notifications)\n        .set({\n          isRead: true,\n          readAt: new Date(),\n        })\n        .where(and(\n          eq(notifications.userId, userId),\n          eq(notifications.isRead, false)\n        ));\n\n      this.logger.log(`‚úÖ All notifications marked as read for user ${userId}`);\n\n      return { success: true, message: 'All notifications marked as read' };\n    } catch (error) {\n      this.logger.error(`‚ùå Error marking all as read: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Deactivate a push token\n   */\n  async deactivateToken(token: string) {\n    try {\n      await this.db\n        .update(pushTokens)\n        .set({\n          isActive: false,\n          updatedAt: new Date(),\n        })\n        .where(eq(pushTokens.token, token));\n\n      this.logger.log(`‚úÖ Token deactivated: ${token}`);\n\n      return { success: true, message: 'Token deactivated' };\n    } catch (error) {\n      this.logger.error(`‚ùå Error deactivating token: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete old notifications (cleanup job)\n   */\n  async deleteOldNotifications(daysOld = 90) {\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n      const result = await this.db\n        .delete(notifications)\n        .where(sql`${notifications.sentAt} < ${cutoffDate}`)\n        .returning();\n\n      this.logger.log(`üóëÔ∏è Deleted ${result.length} old notifications`);\n\n      return {\n        success: true,\n        deleted: result.length,\n        message: `Deleted notifications older than ${daysOld} days`,\n      };\n    } catch (error) {\n      this.logger.error(`‚ùå Error deleting old notifications: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Send push notification directly to a token (for scheduler/cron jobs)\n   */\n  async sendPushNotificationToToken(\n    token: string,\n    title: string,\n    body: string,\n    data?: any\n  ) {\n    try {\n      if (!Expo.isExpoPushToken(token)) {\n        throw new BadRequestException('Invalid Expo push token format');\n      }\n\n      const message: ExpoPushMessage = {\n        to: token,\n        sound: 'default',\n        title,\n        body,\n        data: data || {},\n        priority: 'high',\n      };\n\n      const tickets = await this.expo.sendPushNotificationsAsync([message]);\n      \n      this.logger.log(`üì§ Push notification sent to token`);\n\n      return {\n        success: true,\n        tickets,\n      };\n    } catch (error) {\n      this.logger.error(`‚ùå Error sending push notification to token: ${error.message}`);\n      throw error;\n    }\n  }\n}\n"],"names":["NotificationsService","registerPushToken","userId","token","deviceInfo","Expo","isExpoPushToken","BadRequestException","existing","db","select","from","pushTokens","where","eq","limit","length","update","set","isActive","lastUsedAt","Date","updatedAt","deviceType","platform","deviceName","logger","log","newToken","insert","values","success","message","error","sendNotification","title","body","data","type","newNotification","JSON","parse","stringify","notification","notifications","returning","id","tokens","and","warn","sent","reason","notificationId","validTokens","filter","t","messages","map","to","sound","priority","channelId","chunks","expo","chunkPushNotifications","tickets","chunk","ticketChunk","sendPushNotificationsAsync","push","pushSent","pushSentAt","errors","ticket","status","forEach","sendBulkNotifications","userIds","results","Promise","allSettled","successful","r","failed","total","getUserNotifications","offset","userNotifications","orderBy","desc","sentAt","count","sql","Number","getUnreadCount","result","isRead","markAsRead","readAt","markAllAsRead","deactivateToken","deleteOldNotifications","daysOld","cutoffDate","setDate","getDate","delete","deleted","sendPushNotificationToToken","Logger","name"],"mappings":"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"}