{"version":3,"sources":["../../src/messages/messages.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ForbiddenException, Inject } from '@nestjs/common';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport { CreateMessageDto, CreateMaintenanceRequestDto } from './dto/message.dto';\nimport { PaginationDto } from '../common/dto/pagination.dto';\nimport { messages, maintenanceRequests, Message, MaintenanceRequest, NewMessage, NewMaintenanceRequest } from '../database/schema/messages';\nimport { users } from '../database/schema/users';\nimport { properties } from '../database/schema/properties';\nimport { eq, or, and, desc, asc } from 'drizzle-orm';\n\n@Injectable()\nexport class MessagesService {\n  constructor(@Inject(DATABASE_CONNECTION) private readonly db: any) {}\n\n  async create(senderId: string, createMessageDto: CreateMessageDto): Promise<Message> {\n    // Verify receiver exists\n    const [receiver] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, createMessageDto.receiverId));\n\n    if (!receiver) {\n      throw new NotFoundException('Receiver not found');\n    }\n\n    const messageData: NewMessage = {\n      senderId,\n      receiverId: createMessageDto.receiverId,\n      subject: createMessageDto.subject,\n      content: createMessageDto.content,\n    };\n\n    const [message] = await this.db.insert(messages).values(messageData).returning();\n    return message;\n  }\n\n  async getConversations(userId: string) {\n    try {\n      // Get all messages where user is sender or receiver\n      const userMessages = await this.db\n        .select({\n          id: messages.id,\n          senderId: messages.senderId,\n          receiverId: messages.receiverId,\n          content: messages.content,\n          createdAt: messages.createdAt,\n        })\n        .from(messages)\n        .where(\n          or(\n            eq(messages.senderId, userId),\n            eq(messages.receiverId, userId)\n          )\n        )\n        .orderBy(desc(messages.createdAt));\n\n      // Group by other user and get latest message\n      const conversationsMap = new Map();\n      \n      for (const message of userMessages) {\n        const otherUserId = message.senderId === userId ? message.receiverId : message.senderId;\n        \n        if (!conversationsMap.has(otherUserId)) {\n          // Get the other user's details\n          const [otherUser] = await this.db\n            .select({\n              firstName: users.firstName,\n              lastName: users.lastName,\n            })\n            .from(users)\n            .where(eq(users.id, otherUserId));\n\n          if (otherUser) {\n            conversationsMap.set(otherUserId, {\n              otherUserId,\n              otherUserName: otherUser.firstName,\n              otherUserLastName: otherUser.lastName,\n              lastMessage: message.content,\n              lastMessageTime: message.createdAt,\n            });\n          }\n        }\n      }\n\n      return Array.from(conversationsMap.values());\n    } catch (error) {\n      console.error('Error getting conversations:', error);\n      return [];\n    }\n  }\n\n  async getConversation(\n    userId: string, \n    otherUserId: string, \n    paginationDto: PaginationDto\n  ) {\n    const { page = 1, limit = 20 } = paginationDto;\n    const offset = (page - 1) * limit;\n\n    const conversation = await this.db\n      .select({\n        id: messages.id,\n        senderId: messages.senderId,\n        receiverId: messages.receiverId,\n        subject: messages.subject,\n        content: messages.content,\n        status: messages.status,\n        isRead: messages.isRead,\n        createdAt: messages.createdAt,\n        senderName: users.firstName,\n        senderLastName: users.lastName,\n      })\n      .from(messages)\n      .leftJoin(users, eq(users.id, messages.senderId))\n      .where(\n        or(\n          and(eq(messages.senderId, userId), eq(messages.receiverId, otherUserId)),\n          and(eq(messages.senderId, otherUserId), eq(messages.receiverId, userId))\n        )\n      )\n      .orderBy(asc(messages.createdAt))\n      .limit(limit)\n      .offset(offset);\n\n    return conversation;\n  }\n\n  async markAsRead(messageId: string, userId: string): Promise<Message> {\n    // Verify user is the receiver of the message\n    const [message] = await this.db\n      .select()\n      .from(messages)\n      .where(eq(messages.id, messageId));\n\n    if (!message) {\n      throw new NotFoundException('Message not found');\n    }\n\n    if (message.receiverId !== userId) {\n      throw new ForbiddenException('You can only mark your own messages as read');\n    }\n\n    const [updatedMessage] = await this.db\n      .update(messages)\n      .set({ \n        isRead: true, \n        readAt: new Date(),\n        updatedAt: new Date() \n      })\n      .where(eq(messages.id, messageId))\n      .returning();\n\n    return updatedMessage;\n  }\n\n  async getUnreadCount(userId: string): Promise<{ count: number }> {\n    const unreadMessages = await this.db\n      .select()\n      .from(messages)\n      .where(\n        and(\n          eq(messages.receiverId, userId),\n          eq(messages.isRead, false)\n        )\n      );\n\n    return { count: unreadMessages.length };\n  }\n\n  // Maintenance Request methods\n  async createMaintenanceRequest(\n    tenantId: string, \n    createMaintenanceRequestDto: CreateMaintenanceRequestDto\n  ): Promise<MaintenanceRequest> {\n    // For now, get the first available property and its landlord\n    // This should be improved with proper tenant-property relationships\n    const tenantProperty = await this.db\n      .select({\n        propertyId: properties.id,\n        landlordId: properties.landlordId,\n      })\n      .from(properties)\n      .limit(1);\n\n    if (!tenantProperty.length) {\n      throw new NotFoundException('No properties available');\n    }\n\n    const { propertyId, landlordId } = tenantProperty[0];\n\n    const requestData: NewMaintenanceRequest = {\n      tenantId,\n      landlordId,\n      propertyId,\n      title: createMaintenanceRequestDto.title,\n      description: createMaintenanceRequestDto.description,\n      priority: createMaintenanceRequestDto.priority || 'medium',\n      images: createMaintenanceRequestDto.images || [],\n    };\n\n    const [request] = await this.db.insert(maintenanceRequests).values(requestData).returning();\n    return request;\n  }\n\n  async getMaintenanceRequests(userId: string, role: string) {\n    const whereCondition = role === 'tenant' \n      ? eq(maintenanceRequests.tenantId, userId)\n      : eq(maintenanceRequests.landlordId, userId);\n\n    return this.db\n      .select({\n        id: maintenanceRequests.id,\n        title: maintenanceRequests.title,\n        description: maintenanceRequests.description,\n        priority: maintenanceRequests.priority,\n        status: maintenanceRequests.status,\n        images: maintenanceRequests.images,\n        createdAt: maintenanceRequests.createdAt,\n        updatedAt: maintenanceRequests.updatedAt,\n        tenantName: users.firstName,\n        tenantLastName: users.lastName,\n        propertyName: properties.name,\n      })\n      .from(maintenanceRequests)\n      .leftJoin(users, eq(users.id, maintenanceRequests.tenantId))\n      .leftJoin(properties, eq(properties.id, maintenanceRequests.propertyId))\n      .where(whereCondition)\n      .orderBy(desc(maintenanceRequests.createdAt));\n  }\n} "],"names":["MessagesService","create","senderId","createMessageDto","receiver","db","select","from","users","where","eq","id","receiverId","NotFoundException","messageData","subject","content","message","insert","messages","values","returning","getConversations","userId","userMessages","createdAt","or","orderBy","desc","conversationsMap","Map","otherUserId","has","otherUser","firstName","lastName","set","otherUserName","otherUserLastName","lastMessage","lastMessageTime","Array","error","console","getConversation","paginationDto","page","limit","offset","conversation","status","isRead","senderName","senderLastName","leftJoin","and","asc","markAsRead","messageId","ForbiddenException","updatedMessage","update","readAt","Date","updatedAt","getUnreadCount","unreadMessages","count","length","createMaintenanceRequest","tenantId","createMaintenanceRequestDto","tenantProperty","propertyId","properties","landlordId","requestData","title","description","priority","images","request","maintenanceRequests","getMaintenanceRequests","role","whereCondition","tenantName","tenantLastName","propertyName","name"],"mappings":"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"}