{"version":3,"sources":["../../src/tenant-invitations/tenant-invitations.service.ts"],"sourcesContent":["import { Injectable, Inject, NotFoundException, BadRequestException } from '@nestjs/common';\nimport { eq, and } from 'drizzle-orm';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport { tenantInvitations, NewTenantInvitation, TenantInvitation, units, properties, users, leases } from '../database/schema';\nimport { LandlordPayoutType } from '../tenant-rent-contracts/dto/tenant-rent-contract.dto';\nimport { UsersService } from '../users/users.service';\nimport { v4 as uuidv4 } from 'uuid';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class TenantInvitationsService {\n  constructor(\n    @Inject(DATABASE_CONNECTION) private readonly db: any,\n    private readonly usersService: UsersService,\n  ) { }\n\n  private generateInvitationToken(): string {\n    // Generate a 6-digit alphanumeric code (easier for users to type)\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let result = '';\n    for (let i = 0; i < 6; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  async createInvitation(invitationData: {\n    landlordId: string;\n    propertyId: string;\n    unitId: string;\n    firstName: string;\n    lastName: string;\n    email: string;\n    phone: string;\n    nextOfKinName?: string;\n    nextOfKinPhone?: string;\n    leaseStartDate: string;\n    leaseEndDate: string;\n    monthlyRent: number;\n    securityDeposit?: number;\n    notes?: string;\n    landlordPayoutType?: 'monthly' | 'yearly';\n    isExistingTenant?: boolean;\n    originalExpiryDate?: string;\n  }): Promise<TenantInvitation> {\n    // Check if unit exists and is available\n    const [unit] = await this.db\n      .select()\n      .from(units)\n      .where(and(\n        eq(units.id, invitationData.unitId),\n        eq(units.propertyId, invitationData.propertyId),\n        eq(units.isAvailable, true)\n      ));\n\n    if (!unit) {\n      throw new BadRequestException('Unit not found or not available');\n    }\n\n    // Check if there's already a pending invitation for this email and unit\n    const existingInvitation = await this.db\n      .select()\n      .from(tenantInvitations)\n      .where(and(\n        eq(tenantInvitations.email, invitationData.email),\n        eq(tenantInvitations.unitId, invitationData.unitId),\n        eq(tenantInvitations.status, 'pending')\n      ));\n\n    if (existingInvitation.length > 0) {\n      throw new BadRequestException('An invitation for this email and unit already exists');\n    }\n\n    // Generate invitation token\n    const invitationToken = this.generateInvitationToken();\n\n    // Set expiration date (30 days from now)\n    const expiresAt = new Date();\n    expiresAt.setDate(expiresAt.getDate() + 30);\n\n    // Debug logging to check the landlordId\n    console.log('=== TENANT INVITATION DEBUG ===');\n    console.log('Received landlordId:', invitationData.landlordId);\n    console.log('Invitation data:', JSON.stringify(invitationData, null, 2));\n    console.log('=== END DEBUG ===');\n\n    // Build enhanced notes with contract information\n    let enhancedNotes = invitationData.notes || '';\n    \n    if (invitationData.landlordPayoutType) {\n      enhancedNotes += `${enhancedNotes ? ', ' : ''}Landlord Payout: ${invitationData.landlordPayoutType}`;\n    }\n    \n    if (invitationData.isExistingTenant !== undefined) {\n      enhancedNotes += `${enhancedNotes ? ', ' : ''}Existing Tenant: ${invitationData.isExistingTenant}`;\n    }\n    \n    if (invitationData.originalExpiryDate) {\n      enhancedNotes += `${enhancedNotes ? ', ' : ''}Original Expiry: ${invitationData.originalExpiryDate}`;\n    }\n\n    const newInvitation: NewTenantInvitation = {\n      invitationToken,\n      landlordId: invitationData.landlordId,\n      propertyId: invitationData.propertyId,\n      unitId: invitationData.unitId,\n      firstName: invitationData.firstName,\n      lastName: invitationData.lastName,\n      email: invitationData.email,\n      phone: invitationData.phone || '',\n      emergencyContact: invitationData.nextOfKinName || null,\n      emergencyPhone: invitationData.nextOfKinPhone || null,\n      leaseStartDate: new Date(invitationData.leaseStartDate),\n      leaseEndDate: new Date(invitationData.leaseEndDate),\n      monthlyRent: invitationData.monthlyRent.toString(),\n      securityDeposit: invitationData.securityDeposit?.toString() || null,\n      notes: enhancedNotes || null,\n      expiresAt,\n    };\n\n    // Create the invitation record with explicit field mapping\n    const insertData = {\n      invitationToken: invitationToken,\n      landlordId: invitationData.landlordId,\n      propertyId: invitationData.propertyId,\n      unitId: invitationData.unitId,\n      firstName: invitationData.firstName,\n      lastName: invitationData.lastName,\n      email: invitationData.email,\n      phone: invitationData.phone || '',\n      emergencyContact: invitationData.nextOfKinName || null,\n      emergencyPhone: invitationData.nextOfKinPhone || null,\n      leaseStartDate: new Date(invitationData.leaseStartDate),\n      leaseEndDate: new Date(invitationData.leaseEndDate),\n      monthlyRent: invitationData.monthlyRent.toString(),\n      securityDeposit: invitationData.securityDeposit?.toString() || null,\n      notes: enhancedNotes || null,\n      expiresAt: expiresAt,\n    };\n\n    console.log('Insert data:', JSON.stringify(insertData, null, 2));\n\n    const [invitation] = await this.db\n      .insert(tenantInvitations)\n      .values(insertData)\n      .returning();\n\n\n\n    // Mark unit as reserved (optional - you might want to keep it available until accepted)\n    // await this.db\n    //   .update(units)\n    //   .set({ isAvailable: false })\n    //   .where(eq(units.id, invitationData.unitId));\n\n    return invitation;\n  }\n\n  async getInvitationByToken(token: string): Promise<TenantInvitation & { property: any; unit: any } | null> {\n    const [invitation] = await this.db\n      .select({\n        invitation: tenantInvitations,\n        property: properties,\n        unit: units,\n      })\n      .from(tenantInvitations)\n      .leftJoin(properties, eq(tenantInvitations.propertyId, properties.id))\n      .leftJoin(units, eq(tenantInvitations.unitId, units.id))\n      .where(eq(tenantInvitations.invitationToken, token));\n\n    if (!invitation) {\n      return null;\n    }\n\n    return {\n      ...invitation.invitation,\n      property: invitation.property,\n      unit: invitation.unit,\n    };\n  }\n\n  async acceptInvitation(token: string, tenantId: string): Promise<TenantInvitation> {\n    const invitation = await this.getInvitationByToken(token);\n\n    if (!invitation) {\n      throw new NotFoundException('Invitation not found');\n    }\n\n    if (invitation.status !== 'pending') {\n      throw new BadRequestException('Invitation is no longer valid');\n    }\n\n    if (new Date() > invitation.expiresAt) {\n      throw new BadRequestException('Invitation has expired');\n    }\n\n    // Update invitation status\n    const [updatedInvitation] = await this.db\n      .update(tenantInvitations)\n      .set({\n        status: 'accepted',\n        tenantId,\n        acceptedAt: new Date(),\n        updatedAt: new Date(),\n      })\n      .where(eq(tenantInvitations.invitationToken, token))\n      .returning();\n\n    // Mark unit as occupied\n    await this.db\n      .update(units)\n      .set({ isAvailable: false })\n      .where(eq(units.id, invitation.unitId));\n\n    // Create lease record\n    try {\n      // Format dates as strings for date fields (not timestamp)\n      const startDate = new Date(invitation.leaseStartDate);\n      const endDate = new Date(invitation.leaseEndDate);\n      \n      await this.db.insert(leases).values({\n        tenantId,\n        landlordId: invitation.landlordId,\n        propertyId: invitation.propertyId,\n        unitId: invitation.unitId,\n        startDate: startDate.toISOString().split('T')[0], // Format as YYYY-MM-DD\n        endDate: endDate.toISOString().split('T')[0], // Format as YYYY-MM-DD\n        monthlyRent: invitation.monthlyRent,\n        securityDeposit: invitation.securityDeposit,\n        status: 'active',\n        signedAt: new Date(),\n      });\n      console.log('‚úÖ Lease created successfully for tenant:', tenantId);\n    } catch (error) {\n      console.error('‚ùå Error creating lease:', error);\n      // Don't fail the invitation acceptance if lease creation fails\n    }\n\n    // Create rent contract if landlord payout preference is specified in notes\n    try {\n      await this.createRentContractFromInvitation(updatedInvitation, invitation);\n    } catch (error) {\n      console.error('Error creating rent contract:', error);\n      // Don't fail the invitation acceptance if rent contract creation fails\n    }\n\n    // Payment schedules are now handled through the tenant_rent_contracts table\n    // See ContractsService for creating contracts which manage payment schedules\n    console.log('Payment schedules are now managed through rent contracts');\n\n    return updatedInvitation;\n  }\n\n  /**\n   * Create rent contract from accepted invitation\n   */\n  private async createRentContractFromInvitation(invitation: TenantInvitation, invitationDetails: any): Promise<void> {\n    // Parse landlord payout preference and existing tenant status from notes\n    const notes = invitation.notes || '';\n    let landlordPayoutType = 'monthly'; // default\n    let isExistingTenant = false;\n    let originalExpiryDate: Date | null = null;\n\n    // Parse notes for contract information\n    // Expected format: \"Payment Frequency: Monthly, Landlord Payout: yearly, Existing Tenant: true, Original Expiry: 2024-06-30\"\n    if (notes.includes('Landlord Payout:')) {\n      const payoutMatch = notes.match(/Landlord Payout:\\s*(monthly|yearly)/i);\n      if (payoutMatch) {\n        landlordPayoutType = payoutMatch[1].toLowerCase();\n      }\n    }\n\n    if (notes.includes('Existing Tenant:')) {\n      const existingMatch = notes.match(/Existing Tenant:\\s*(true|false)/i);\n      if (existingMatch) {\n        isExistingTenant = existingMatch[1].toLowerCase() === 'true';\n      }\n    }\n\n    if (notes.includes('Original Expiry:')) {\n      const expiryMatch = notes.match(/Original Expiry:\\s*(\\d{4}-\\d{2}-\\d{2})/);\n      if (expiryMatch) {\n        originalExpiryDate = new Date(expiryMatch[1]);\n      }\n    }\n\n    // Only create rent contract if we have the necessary information\n    if (notes.includes('Landlord Payout:')) {\n      // Import TenantPaymentService dynamically to avoid circular dependency\n      const { TenantPaymentService } = await import('../tenant-rent-contracts/tenant-payment.service');\n      const tenantPaymentService = new TenantPaymentService(this.db);\n\n      const contractData = {\n        tenantId: invitation.tenantId!,\n        landlordId: invitation.landlordId,\n        propertyId: invitation.propertyId,\n        unitId: invitation.unitId,\n        monthlyAmount: parseFloat(invitation.monthlyRent),\n        expiryDate: invitation.leaseEndDate.toISOString(),\n        landlordPayoutType: landlordPayoutType as LandlordPayoutType,\n        isExistingTenant,\n        originalExpiryDate: originalExpiryDate?.toISOString(),\n      };\n\n      await tenantPaymentService.createRentContract(contractData);\n      console.log('Rent contract created successfully for invitation:', invitation.id);\n    }\n  }\n\n  async getInvitationsByLandlord(landlordId: string): Promise<any[]> {\n    try {\n      console.log('üóÑÔ∏è Querying database for invitations with landlordId:', landlordId);\n      \n      const invitations = await this.db\n        .select({\n          invitation: tenantInvitations,\n          tenant: users, // Include tenant user data if they've accepted\n        })\n        .from(tenantInvitations)\n        .leftJoin(users, eq(tenantInvitations.tenantId, users.id))\n        .where(eq(tenantInvitations.landlordId, landlordId));\n      \n      console.log('üóÑÔ∏è Database returned', invitations.length, 'invitations');\n      \n      // Merge invitation and tenant data, using real email if tenant has accepted\n      const enrichedInvitations = invitations.map(({ invitation, tenant }) => ({\n        ...invitation,\n        // Override with real tenant data if they've accepted\n        email: tenant?.email || invitation.email,\n        phone: tenant?.phoneNumber || invitation.phone,\n        // Add flag to indicate if using real data\n        hasAcceptedAccount: !!tenant,\n      }));\n      \n      return enrichedInvitations;\n    } catch (error) {\n      console.error('‚ùå Error getting invitations by landlord:', error);\n      return [];\n    }\n  }\n\n  async getAcceptedTenantsByLandlord(landlordId: string): Promise<any[]> {\n    try {\n      console.log('üîç Getting accepted tenants for landlord:', landlordId);\n      \n      const acceptedInvitations = await this.db\n        .select({\n          invitation: tenantInvitations,\n          property: properties,\n          unit: units,\n        })\n        .from(tenantInvitations)\n        .leftJoin(properties, eq(tenantInvitations.propertyId, properties.id))\n        .leftJoin(units, eq(tenantInvitations.unitId, units.id))\n        .where(and(\n          eq(tenantInvitations.landlordId, landlordId),\n          eq(tenantInvitations.status, 'accepted')\n        ));\n\n      console.log('üîç Found accepted invitations:', acceptedInvitations.length);\n\n      const result = acceptedInvitations.map(result => ({\n        // Flatten invitation data to top level for easier access\n        id: result.invitation.id,\n        propertyId: result.invitation.propertyId,\n        unitId: result.invitation.unitId,\n        firstName: result.invitation.firstName,\n        lastName: result.invitation.lastName,\n        email: result.invitation.email,\n        phone: result.invitation.phone,\n        monthlyRent: result.invitation.monthlyRent,\n        securityDeposit: result.invitation.securityDeposit,\n        status: result.invitation.status,\n        leaseStartDate: result.invitation.leaseStartDate,\n        leaseEndDate: result.invitation.leaseEndDate,\n        createdAt: result.invitation.createdAt,\n        updatedAt: result.invitation.updatedAt,\n        // Include nested objects\n        property: result.property,\n        unit: result.unit,\n      }));\n\n      console.log('üîç Returning tenants:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå Error getting accepted tenants:', error);\n      return [];\n    }\n  }\n\n  async cancelInvitation(invitationId: string, landlordId: string): Promise<void> {\n    const [invitation] = await this.db\n      .select()\n      .from(tenantInvitations)\n      .where(and(\n        eq(tenantInvitations.id, invitationId),\n        eq(tenantInvitations.landlordId, landlordId)\n      ));\n\n    if (!invitation) {\n      throw new NotFoundException('Invitation not found');\n    }\n\n    await this.db\n      .update(tenantInvitations)\n      .set({\n        status: 'cancelled',\n        updatedAt: new Date(),\n      })\n      .where(eq(tenantInvitations.id, invitationId));\n  }\n\n  async validateInvitationToken(token: string): Promise<boolean> {\n    const invitation = await this.getInvitationByToken(token);\n\n    if (!invitation) {\n      return false;\n    }\n\n    if (invitation.status !== 'pending') {\n      return false;\n    }\n\n    if (new Date() > invitation.expiresAt) {\n      // Mark as expired\n      await this.db\n        .update(tenantInvitations)\n        .set({\n          status: 'expired',\n          updatedAt: new Date(),\n        })\n        .where(eq(tenantInvitations.invitationToken, token));\n\n      return false;\n    }\n\n    return true;\n  }\n}"],"names":["TenantInvitationsService","generateInvitationToken","chars","result","i","charAt","Math","floor","random","length","createInvitation","invitationData","unit","db","select","from","units","where","and","eq","id","unitId","propertyId","isAvailable","BadRequestException","existingInvitation","tenantInvitations","email","status","invitationToken","expiresAt","Date","setDate","getDate","console","log","landlordId","JSON","stringify","enhancedNotes","notes","landlordPayoutType","isExistingTenant","undefined","originalExpiryDate","newInvitation","firstName","lastName","phone","emergencyContact","nextOfKinName","emergencyPhone","nextOfKinPhone","leaseStartDate","leaseEndDate","monthlyRent","toString","securityDeposit","insertData","invitation","insert","values","returning","getInvitationByToken","token","property","properties","leftJoin","acceptInvitation","tenantId","NotFoundException","updatedInvitation","update","set","acceptedAt","updatedAt","startDate","endDate","leases","toISOString","split","signedAt","error","createRentContractFromInvitation","invitationDetails","includes","payoutMatch","match","toLowerCase","existingMatch","expiryMatch","TenantPaymentService","tenantPaymentService","contractData","monthlyAmount","parseFloat","expiryDate","createRentContract","getInvitationsByLandlord","invitations","tenant","users","enrichedInvitations","map","phoneNumber","hasAcceptedAccount","getAcceptedTenantsByLandlord","acceptedInvitations","createdAt","cancelInvitation","invitationId","validateInvitationToken","usersService"],"mappings":"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"}