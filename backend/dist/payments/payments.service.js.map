{"version":3,"sources":["../../src/payments/payments.service.ts"],"sourcesContent":["import { Injectable, Inject } from '@nestjs/common';\nimport { eq, and, gte, lte, sql } from 'drizzle-orm';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport { payments, tenantInvitations, users, properties, units, NewPayment } from '../database/schema';\n\n@Injectable()\nexport class PaymentsService {\n  constructor(\n    @Inject(DATABASE_CONNECTION) private readonly db: any,\n  ) {}\n\n  /**\n   * Generate monthly payment records for accepted tenant invitations\n   * This should be called when a tenant accepts an invitation\n   */\n  async generatePaymentSchedule(tenantInvitationId: string) {\n    try {\n      // Get the tenant invitation details\n      const [invitation] = await this.db\n        .select()\n        .from(tenantInvitations)\n        .where(eq(tenantInvitations.id, tenantInvitationId));\n\n      if (!invitation || invitation.status !== 'accepted') {\n        throw new Error('Tenant invitation not found or not accepted');\n      }\n\n      const moveInDate = new Date(invitation.leaseStartDate);\n      const leaseEnd = new Date(invitation.leaseEndDate);\n      const monthlyRent = parseFloat(invitation.monthlyRent);\n\n      console.log(`Generating payment schedule for tenant from ${moveInDate.toISOString()} to ${leaseEnd.toISOString()}`);\n\n      // Generate monthly payments from move-in date\n      const paymentsToCreate: NewPayment[] = [];\n      let currentPaymentDate = new Date(moveInDate);\n\n      const today = new Date();\n      \n      // First payment (move-in month) - if move-in date is today or in the past, mark as paid\n      while (currentPaymentDate <= leaseEnd) {\n        const dueDate = new Date(currentPaymentDate);\n        const isFirstPayment = currentPaymentDate.getTime() === moveInDate.getTime();\n        \n        // If tenant moved in today or earlier, they should have paid for that month\n        let status = 'pending';\n        let amountPaid = '0.00';\n        let paidDate: Date | null = null;\n        \n        if (isFirstPayment && moveInDate <= today) {\n          status = 'paid';\n          amountPaid = monthlyRent.toFixed(2);\n          paidDate = new Date(moveInDate);\n          console.log(`Marking first payment as paid since tenant moved in on ${moveInDate.toDateString()}`);\n        }\n        \n        paymentsToCreate.push({\n          landlordId: invitation.landlordId,\n          tenantId: invitation.tenantId!,\n          propertyId: invitation.propertyId,\n          unitId: invitation.unitId,\n          tenantInvitationId: invitation.id,\n          amount: monthlyRent.toFixed(2),\n          amountPaid: amountPaid,\n          dueDate: dueDate,\n          paidDate: paidDate,\n          paymentType: 'rent',\n          status: status as any,\n          description: `Monthly rent for ${dueDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`,\n        } as NewPayment);\n\n        // Move to next month (same day of next month)\n        currentPaymentDate.setMonth(currentPaymentDate.getMonth() + 1);\n      }\n\n      console.log(`Creating ${paymentsToCreate.length} payment records`);\n\n      // Insert all payment records\n      if (paymentsToCreate.length > 0) {\n        const result = await this.db.insert(payments).values(paymentsToCreate);\n        console.log(`Successfully inserted ${paymentsToCreate.length} payment records`);\n      }\n\n      return paymentsToCreate;\n    } catch (error) {\n      console.error('Error generating payment schedule:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get upcoming payments (due in next 7 days) for a landlord\n   */\n  async getUpcomingPayments(landlordId: string) {\n    try {\n      const today = new Date();\n      const nextWeek = new Date();\n      nextWeek.setDate(today.getDate() + 7);\n\n      const upcomingPayments = await this.db\n        .select({\n          payment: payments,\n          tenant: users,\n          property: properties,\n          unit: units,\n        })\n        .from(payments)\n        .leftJoin(users, eq(payments.tenantId, users.id))\n        .leftJoin(properties, eq(payments.propertyId, properties.id))\n        .leftJoin(units, eq(payments.unitId, units.id))\n        .where(and(\n          eq(payments.landlordId, landlordId),\n          eq(payments.status, 'pending'),\n          gte(payments.dueDate, today),\n          lte(payments.dueDate, nextWeek)\n        ));\n\n      return upcomingPayments;\n    } catch (error) {\n      console.error('Error getting upcoming payments:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get overdue payments for a landlord\n   */\n  async getOverduePayments(landlordId: string) {\n    try {\n      const today = new Date();\n\n      const overduePayments = await this.db\n        .select({\n          payment: payments,\n          tenant: users,\n          property: properties,\n          unit: units,\n        })\n        .from(payments)\n        .leftJoin(users, eq(payments.tenantId, users.id))\n        .leftJoin(properties, eq(payments.propertyId, properties.id))\n        .leftJoin(units, eq(payments.unitId, units.id))\n        .where(and(\n          eq(payments.landlordId, landlordId),\n          eq(payments.status, 'pending'),\n          lte(payments.dueDate, today)\n        ));\n\n      return overduePayments;\n    } catch (error) {\n      console.error('Error getting overdue payments:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get payment statistics for landlord dashboard\n   */\n  async getPaymentStats(landlordId: string) {\n    try {\n      const today = new Date();\n      const nextWeek = new Date();\n      nextWeek.setDate(today.getDate() + 7);\n\n      const currentYear = new Date().getFullYear();\n      const yearStart = new Date(currentYear, 0, 1);\n      const yearEnd = new Date(currentYear, 11, 31, 23, 59, 59);\n\n      console.log(`Getting payment stats for landlord ${landlordId} for year ${currentYear}`);\n\n      // Get upcoming payments (next 7 days) - pending payments due within 7 days\n      const upcomingPayments = await this.db\n        .select()\n        .from(payments)\n        .where(and(\n          eq(payments.landlordId, landlordId),\n          eq(payments.status, 'pending'),\n          gte(payments.dueDate, today),\n          lte(payments.dueDate, nextWeek)\n        ));\n\n      const upcomingCount = upcomingPayments.length;\n      const upcomingAmount = upcomingPayments.reduce((sum, payment) => {\n        return sum + parseFloat(payment.amount || '0');\n      }, 0);\n\n      console.log(`Upcoming payments: ${upcomingCount} payments totaling ${upcomingAmount}`);\n\n      // Get overdue payments - pending payments that are past due date\n      const overduePayments = await this.db\n        .select()\n        .from(payments)\n        .where(and(\n          eq(payments.landlordId, landlordId),\n          eq(payments.status, 'pending'),\n          lte(payments.dueDate, today)\n        ));\n\n      const overdueAmount = overduePayments.reduce((sum, payment) => {\n        const amount = parseFloat(payment.amount || '0');\n        const amountPaid = parseFloat(payment.amountPaid || '0');\n        return sum + (amount - amountPaid);\n      }, 0);\n      const overdueTenants = new Set(overduePayments.map(p => p.tenantId)).size;\n\n      console.log(`Overdue payments: ${overduePayments.length} payments totaling ${overdueAmount} from ${overdueTenants} tenants`);\n\n      // Get rent collected this year - all payments marked as paid this year\n      const paidPayments = await this.db\n        .select()\n        .from(payments)\n        .where(and(\n          eq(payments.landlordId, landlordId),\n          eq(payments.status, 'paid')\n        ));\n\n      // Filter by year in JavaScript to handle null paidDate\n      const paidThisYear = paidPayments.filter(payment => {\n        if (!payment.paidDate) return false;\n        const paidDate = new Date(payment.paidDate);\n        return paidDate >= yearStart && paidDate <= yearEnd;\n      });\n\n      const rentCollected = paidThisYear.reduce((sum, payment) => {\n        return sum + parseFloat(payment.amountPaid || '0');\n      }, 0);\n\n      console.log(`Rent collected this year: ${rentCollected} from ${paidThisYear.length} payments`);\n\n      const stats = {\n        upcomingPayments: upcomingCount,\n        upcomingPaymentsCombined: upcomingAmount,\n        outstandingRent: overdueAmount,\n        outstandingRentTenants: overdueTenants,\n        rentCollected,\n      };\n\n      console.log('Final payment stats:', stats);\n      return stats;\n    } catch (error) {\n      console.error('Error getting payment stats:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process a payment - mark payment as paid and update status\n   */\n  async processPayment(paymentId: string, amountPaid: number, paymentMethod?: string, notes?: string) {\n    try {\n      const [payment] = await this.db\n        .select()\n        .from(payments)\n        .where(eq(payments.id, paymentId));\n\n      if (!payment) {\n        throw new Error('Payment not found');\n      }\n\n      const totalAmount = parseFloat(payment.amount);\n      const previousAmountPaid = parseFloat(payment.amountPaid || '0');\n      const newAmountPaid = previousAmountPaid + amountPaid;\n      \n      let status = 'partial';\n      if (newAmountPaid >= totalAmount) {\n        status = 'paid';\n      }\n\n      console.log(`Processing payment ${paymentId}: ${amountPaid} added, total now ${newAmountPaid}/${totalAmount}, status: ${status}`);\n\n      // Update payment record\n      await this.db\n        .update(payments)\n        .set({\n          amountPaid: newAmountPaid.toString(),\n          status: status as any,\n          paidDate: status === 'paid' ? new Date() : payment.paidDate,\n          paymentMethod: paymentMethod as any || payment.paymentMethod,\n          notes: notes || payment.notes,\n          updatedAt: new Date(),\n        })\n        .where(eq(payments.id, paymentId));\n\n      return { \n        success: true, \n        newStatus: status,\n        totalPaid: newAmountPaid,\n        remainingAmount: totalAmount - newAmountPaid\n      };\n    } catch (error) {\n      console.error('Error processing payment:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all payments for a tenant\n   */\n  async getTenantPayments(tenantId: string) {\n    try {\n      const tenantPayments = await this.db\n        .select({\n          payment: payments,\n          property: properties,\n          unit: units,\n        })\n        .from(payments)\n        .leftJoin(properties, eq(payments.propertyId, properties.id))\n        .leftJoin(units, eq(payments.unitId, units.id))\n        .where(eq(payments.tenantId, tenantId))\n        .orderBy(payments.dueDate);\n\n      return tenantPayments;\n    } catch (error) {\n      console.error('Error getting tenant payments:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all payments for a landlord\n   */\n  async getLandlordPayments(landlordId: string) {\n    try {\n      const landlordPayments = await this.db\n        .select({\n          payment: payments,\n          tenant: users,\n          property: properties,\n          unit: units,\n        })\n        .from(payments)\n        .leftJoin(users, eq(payments.tenantId, users.id))\n        .leftJoin(properties, eq(payments.propertyId, properties.id))\n        .leftJoin(units, eq(payments.unitId, units.id))\n        .where(eq(payments.landlordId, landlordId))\n        .orderBy(payments.dueDate);\n\n      return landlordPayments;\n    } catch (error) {\n      console.error('Error getting landlord payments:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update overdue payments status\n   * This should be run periodically to mark pending payments as overdue\n   */\n  async updateOverduePayments() {\n    try {\n      const today = new Date();\n\n      const result = await this.db\n        .update(payments)\n        .set({\n          status: 'overdue',\n          updatedAt: new Date(),\n        })\n        .where(and(\n          eq(payments.status, 'pending'),\n          lte(payments.dueDate, today)\n        ));\n\n      console.log('Updated overdue payments');\n      return result;\n    } catch (error) {\n      console.error('Error updating overdue payments:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Record a payment after successful verification\n   */\n  async recordPayment(paymentData: {\n    tenantId: string;\n    amount: number;\n    reference: string;\n    paymentMethod: string;\n    status: string;\n    paidAt: Date;\n    metadata?: any;\n  }) {\n    try {\n      // Find the pending payment for this tenant and amount to mark as paid\n      const [existingPayment] = await this.db\n        .select()\n        .from(payments)\n        .where(and(\n          eq(payments.tenantId, paymentData.tenantId),\n          eq(payments.status, 'pending'),\n          eq(payments.amount, paymentData.amount.toString())\n        ))\n        .limit(1);\n\n      if (existingPayment) {\n        // Update existing payment\n        const result = await this.db\n          .update(payments)\n          .set({\n            status: paymentData.status,\n            amountPaid: paymentData.amount.toString(),\n            paidDate: paymentData.paidAt,\n            paymentMethod: paymentData.paymentMethod,\n            reference: paymentData.reference,\n            metadata: paymentData.metadata,\n            updatedAt: new Date(),\n          })\n          .where(eq(payments.id, existingPayment.id));\n\n        console.log('Payment updated successfully:', paymentData.reference);\n        return result;\n      } else {\n        // Create new payment record\n        const result = await this.db\n          .insert(payments)\n          .values({\n            tenantId: paymentData.tenantId,\n            amount: paymentData.amount.toString(),\n            amountPaid: paymentData.amount.toString(),\n            status: paymentData.status,\n            paidDate: paymentData.paidAt,\n            paymentMethod: paymentData.paymentMethod,\n            reference: paymentData.reference,\n            metadata: paymentData.metadata,\n            dueDate: paymentData.paidAt, // Use paid date as due date for ad-hoc payments\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          });\n\n        console.log('Payment recorded successfully:', paymentData.reference);\n        return result;\n      }\n    } catch (error) {\n      console.error('Error recording payment:', error);\n      throw error;\n    }\n  }\n}"],"names":["PaymentsService","generatePaymentSchedule","tenantInvitationId","invitation","db","select","from","tenantInvitations","where","eq","id","status","Error","moveInDate","Date","leaseStartDate","leaseEnd","leaseEndDate","monthlyRent","parseFloat","console","log","toISOString","paymentsToCreate","currentPaymentDate","today","dueDate","isFirstPayment","getTime","amountPaid","paidDate","toFixed","toDateString","push","landlordId","tenantId","propertyId","unitId","amount","paymentType","description","toLocaleDateString","month","year","setMonth","getMonth","length","result","insert","payments","values","error","getUpcomingPayments","nextWeek","setDate","getDate","upcomingPayments","payment","tenant","users","property","properties","unit","units","leftJoin","and","gte","lte","getOverduePayments","overduePayments","getPaymentStats","currentYear","getFullYear","yearStart","yearEnd","upcomingCount","upcomingAmount","reduce","sum","overdueAmount","overdueTenants","Set","map","p","size","paidPayments","paidThisYear","filter","rentCollected","stats","upcomingPaymentsCombined","outstandingRent","outstandingRentTenants","processPayment","paymentId","paymentMethod","notes","totalAmount","previousAmountPaid","newAmountPaid","update","set","toString","updatedAt","success","newStatus","totalPaid","remainingAmount","getTenantPayments","tenantPayments","orderBy","getLandlordPayments","landlordPayments","updateOverduePayments","recordPayment","paymentData","existingPayment","limit","paidAt","reference","metadata","createdAt"],"mappings":"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"}