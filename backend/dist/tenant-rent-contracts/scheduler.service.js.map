{"version":3,"sources":["../../src/tenant-rent-contracts/scheduler.service.ts"],"sourcesContent":["import { Injectable, Logger, Inject } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { TenantPaymentService } from './tenant-payment.service';\nimport { LandlordPayoutService } from './landlord-payout.service';\nimport { EmailService } from '../email/email.service';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport { eq, and, lte, gte, inArray, sql } from 'drizzle-orm';\nimport { \n  paymentNotifications, \n  tenantRentContracts,\n  PaymentNotification,\n  TenantRentContract\n} from '../database/schema';\n\n@Injectable()\nexport class SchedulerService {\n  private readonly logger = new Logger(SchedulerService.name);\n  private readonly maxRetries = 3;\n  private readonly retryDelay = 5000; // 5 seconds\n\n  constructor(\n    private readonly tenantPaymentService: TenantPaymentService,\n    private readonly landlordPayoutService: LandlordPayoutService,\n    private readonly emailService: EmailService,\n    @Inject(DATABASE_CONNECTION) private readonly db: any,\n  ) {}\n\n  /**\n   * Daily cron job to check for due payments\n   * Runs every day at 9:00 AM\n   */\n  @Cron(CronExpression.EVERY_DAY_AT_9AM)\n  async checkDuePayments(): Promise<void> {\n    this.logger.log('Starting daily payment due check...');\n    \n    try {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0); // Reset time to start of day\n      \n      // Get all contracts with payments due today or overdue\n      const contractsWithDuePayments = await this.tenantPaymentService.getContractsWithDuePayments(today);\n      \n      this.logger.log(`Found ${contractsWithDuePayments.length} contracts with due payments`);\n      \n      for (const contract of contractsWithDuePayments) {\n        const dueDate = new Date(contract.nextPaymentDue);\n        const daysOverdue = Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));\n        \n        this.logger.log(`Contract ${contract.id}: Payment due ${dueDate.toDateString()}, ${daysOverdue} days overdue`);\n        \n        // Log payment due status for monitoring\n        if (daysOverdue === 0) {\n          this.logger.log(`Payment due today for contract ${contract.id} (Tenant: ${contract.tenantId})`);\n        } else if (daysOverdue > 0) {\n          this.logger.warn(`Payment overdue by ${daysOverdue} days for contract ${contract.id} (Tenant: ${contract.tenantId})`);\n        }\n      }\n      \n      this.logger.log('Daily payment due check completed successfully');\n    } catch (error) {\n      this.logger.error('Error during daily payment due check:', error);\n    }\n  }\n\n  /**\n   * Daily cron job to send payment reminders\n   * Runs every day at 10:00 AM (after due payment check)\n   */\n  @Cron('0 10 * * *')\n  async sendPaymentReminders(): Promise<void> {\n    this.logger.log('Starting payment reminder notifications...');\n    \n    try {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Get contracts with payments due today or overdue\n      const contractsWithDuePayments = await this.tenantPaymentService.getContractsWithDuePayments(today);\n      \n      // Also check for payments due in the next 3 days (early reminders)\n      const reminderDate = new Date(today);\n      reminderDate.setDate(reminderDate.getDate() + 3);\n      const contractsWithUpcomingPayments = await this.tenantPaymentService.getContractsWithDuePayments(reminderDate);\n      \n      // Filter to get only upcoming payments (not already due)\n      const upcomingOnly = contractsWithUpcomingPayments.filter(contract => {\n        const dueDate = new Date(contract.nextPaymentDue);\n        return dueDate > today;\n      });\n      \n      this.logger.log(`Sending reminders for ${contractsWithDuePayments.length} due payments and ${upcomingOnly.length} upcoming payments`);\n      \n      // Send reminders for due/overdue payments\n      for (const contract of contractsWithDuePayments) {\n        await this.sendPaymentReminderNotification(contract, 'due');\n      }\n      \n      // Send early reminders for upcoming payments\n      for (const contract of upcomingOnly) {\n        await this.sendPaymentReminderNotification(contract, 'upcoming');\n      }\n      \n      this.logger.log('Payment reminder notifications completed successfully');\n    } catch (error) {\n      this.logger.error('Error during payment reminder notifications:', error);\n    }\n  }\n\n  /**\n   * Send payment reminder notification to tenant\n   */\n  private async sendPaymentReminderNotification(contract: any, type: 'due' | 'upcoming' | 'overdue'): Promise<void> {\n    try {\n      const dueDate = new Date(contract.nextPaymentDue);\n      const today = new Date();\n      const daysUntilDue = Math.ceil((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));\n      \n      let subject: string;\n      let urgencyLevel: string;\n      \n      if (type === 'due' && daysUntilDue <= 0) {\n        const daysOverdue = Math.abs(daysUntilDue);\n        if (daysOverdue === 0) {\n          subject = 'Rent Payment Due Today';\n          urgencyLevel = 'due';\n        } else {\n          subject = `Rent Payment Overdue - ${daysOverdue} Day(s)`;\n          urgencyLevel = 'overdue';\n        }\n      } else {\n        subject = `Rent Payment Reminder - Due in ${daysUntilDue} Day(s)`;\n        urgencyLevel = 'upcoming';\n      }\n      \n      // For now, we'll log the notification details\n      // In a production system, this would integrate with:\n      // 1. Expo Push Notifications for mobile app users\n      // 2. Email notifications as backup\n      // 3. SMS notifications for critical overdue payments\n      \n      this.logger.log(`[${urgencyLevel.toUpperCase()}] Notification for Contract ${contract.id}:`);\n      this.logger.log(`  Tenant: ${contract.tenantId}`);\n      this.logger.log(`  Subject: ${subject}`);\n      this.logger.log(`  Amount: $${contract.monthlyAmount}`);\n      this.logger.log(`  Due Date: ${dueDate.toDateString()}`);\n      this.logger.log(`  Days Until Due: ${daysUntilDue}`);\n      \n      // TODO: Implement actual notification sending\n      // await this.sendExpoNotification(contract.tenantId, subject, message);\n      // await this.sendEmailNotification(contract.tenantId, subject, message);\n      \n    } catch (error) {\n      this.logger.error(`Failed to send reminder for contract ${contract.id}:`, error);\n    }\n  }\n\n  /**\n   * Send Expo push notification (placeholder for future implementation)\n   */\n  private async sendExpoNotification(tenantId: string, title: string, message: string): Promise<void> {\n    // TODO: Implement Expo push notification\n    // This would require:\n    // 1. Expo SDK integration\n    // 2. User device token storage\n    // 3. Notification payload formatting\n    this.logger.debug(`[EXPO] Would send to ${tenantId}: ${title} - ${message}`);\n  }\n\n  /**\n   * Send email notification using existing EmailService\n   */\n  private async sendEmailNotification(tenantId: string, subject: string, message: string): Promise<void> {\n    try {\n      // TODO: Get tenant email from user service\n      // For now, this is a placeholder\n      // const tenantEmail = await this.userService.getUserEmail(tenantId);\n      // await this.emailService.sendPaymentReminder(tenantEmail, subject, message);\n      \n      this.logger.debug(`[EMAIL] Would send to tenant ${tenantId}: ${subject}`);\n    } catch (error) {\n      this.logger.error(`Failed to send email notification to tenant ${tenantId}:`, error);\n    }\n  }\n\n  /**\n   * Manual method to trigger payment due checks (for testing/admin use)\n   */\n  async triggerPaymentDueCheck(): Promise<void> {\n    this.logger.log('Manual trigger: checking due payments...');\n    await this.checkDuePayments();\n  }\n\n  /**\n   * Manual method to trigger payment reminders (for testing/admin use)\n   */\n  async triggerPaymentReminders(): Promise<void> {\n    this.logger.log('Manual trigger: sending payment reminders...');\n    await this.sendPaymentReminders();\n  }\n\n  /**\n   * Get summary of due payments (for admin dashboard)\n   */\n  async getPaymentDueSummary(): Promise<{\n    totalDue: number;\n    totalOverdue: number;\n    contractsWithDuePayments: number;\n    contractsWithOverduePayments: number;\n  }> {\n    try {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      const contractsWithDuePayments = await this.tenantPaymentService.getContractsWithDuePayments(today);\n      \n      let totalDue = 0;\n      let totalOverdue = 0;\n      let contractsWithOverduePayments = 0;\n      \n      for (const contract of contractsWithDuePayments) {\n        const amount = parseFloat(contract.monthlyAmount);\n        const dueDate = new Date(contract.nextPaymentDue);\n        const daysOverdue = Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));\n        \n        totalDue += amount;\n        \n        if (daysOverdue > 0) {\n          totalOverdue += amount;\n          contractsWithOverduePayments++;\n        }\n      }\n      \n      return {\n        totalDue,\n        totalOverdue,\n        contractsWithDuePayments: contractsWithDuePayments.length,\n        contractsWithOverduePayments,\n      };\n    } catch (error) {\n      this.logger.error('Error getting payment due summary:', error);\n      return {\n        totalDue: 0,\n        totalOverdue: 0,\n        contractsWithDuePayments: 0,\n        contractsWithOverduePayments: 0,\n      };\n    }\n  }\n\n  /**\n   * Daily cron job to process escrow releases for yearly contract completions\n   * Runs every day at 11:00 AM (after payment checks and reminders)\n   */\n  @Cron('0 11 * * *')\n  async processEscrowReleases(): Promise<void> {\n    this.logger.log('Starting daily escrow release processing...');\n    \n    const startTime = Date.now();\n    let processedCount = 0;\n    let errorCount = 0;\n    \n    try {\n      const results = await this.executeWithRetry(\n        () => this.landlordPayoutService.checkEscrowReleases(),\n        'escrow release check'\n      );\n      \n      processedCount = results.length;\n      \n      for (const result of results) {\n        if (result.success) {\n          this.logger.log(`Successfully released escrow: ${result.releasedAmount} to landlord ${result.landlordId}`);\n        } else {\n          errorCount++;\n          this.logger.error(`Failed to release escrow ${result.escrowId}`);\n        }\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.log(`Escrow release processing completed: ${processedCount} processed, ${errorCount} errors, ${duration}ms`);\n      \n      // Log metrics for monitoring\n      this.logOperationMetrics('escrow_releases', {\n        processed: processedCount,\n        errors: errorCount,\n        duration,\n        success: errorCount === 0\n      });\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.error(`Critical error during escrow release processing: ${error.message}`, error.stack);\n      \n      this.logOperationMetrics('escrow_releases', {\n        processed: processedCount,\n        errors: errorCount + 1,\n        duration,\n        success: false,\n        criticalError: error.message\n      });\n    }\n  }\n\n  /**\n   * Daily cron job to update overdue payment statuses\n   * Runs every day at 12:00 PM (after all payment processing)\n   */\n  @Cron('0 12 * * *')\n  async updateOverduePaymentStatuses(): Promise<void> {\n    this.logger.log('Starting overdue payment status updates...');\n    \n    const startTime = Date.now();\n    let updatedCount = 0;\n    let errorCount = 0;\n    \n    try {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Find contracts with overdue payments (nextPaymentDue < today and status is still 'active')\n      const overdueContracts = await this.executeWithRetry(\n        () => this.db\n          .select()\n          .from(tenantRentContracts)\n          .where(and(\n            lte(tenantRentContracts.nextPaymentDue, today),\n            eq(tenantRentContracts.status, 'active')\n          )),\n        'overdue contracts query'\n      ) as any[];\n      \n      this.logger.log(`Found ${overdueContracts.length} contracts with overdue payments`);\n      \n      for (const contract of overdueContracts) {\n        try {\n          const dueDate = new Date(contract.nextPaymentDue);\n          const daysOverdue = Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));\n          \n          if (daysOverdue > 0) {\n            // Log overdue status for monitoring\n            this.logger.warn(`Contract ${contract.id} is ${daysOverdue} days overdue (Due: ${dueDate.toDateString()})`);\n            \n            // Update contract metadata or trigger additional actions based on overdue days\n            if (daysOverdue >= 30) {\n              this.logger.error(`Contract ${contract.id} is critically overdue (${daysOverdue} days)`);\n              // Could trigger escalation processes here\n            }\n            \n            updatedCount++;\n          }\n        } catch (error) {\n          errorCount++;\n          this.logger.error(`Error processing overdue contract ${contract.id}: ${error.message}`);\n        }\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.log(`Overdue status update completed: ${updatedCount} processed, ${errorCount} errors, ${duration}ms`);\n      \n      this.logOperationMetrics('overdue_updates', {\n        processed: updatedCount,\n        errors: errorCount,\n        duration,\n        success: errorCount === 0\n      });\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.error(`Critical error during overdue status updates: ${error.message}`, error.stack);\n      \n      this.logOperationMetrics('overdue_updates', {\n        processed: updatedCount,\n        errors: errorCount + 1,\n        duration,\n        success: false,\n        criticalError: error.message\n      });\n    }\n  }\n\n  /**\n   * Daily cron job to clean up old notifications\n   * Runs every day at 2:00 AM (during low activity period)\n   */\n  @Cron('0 2 * * *')\n  async cleanupNotifications(): Promise<void> {\n    this.logger.log('Starting notification cleanup...');\n    \n    const startTime = Date.now();\n    let cleanedCount = 0;\n    let errorCount = 0;\n    \n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - 30); // Keep notifications for 30 days\n      \n      // Clean up old sent notifications\n      const sentResult = await this.executeWithRetry(\n        () => this.db\n          .delete(paymentNotifications)\n          .where(and(\n            eq(paymentNotifications.status, 'sent'),\n            lte(paymentNotifications.sentAt, cutoffDate)\n          )),\n        'cleanup sent notifications'\n      );\n      \n      // Clean up old failed notifications (keep for shorter period)\n      const failedCutoffDate = new Date();\n      failedCutoffDate.setDate(failedCutoffDate.getDate() - 7); // Keep failed for 7 days\n      \n      const failedResult = await this.executeWithRetry(\n        () => this.db\n          .delete(paymentNotifications)\n          .where(and(\n            eq(paymentNotifications.status, 'failed'),\n            lte(paymentNotifications.createdAt, failedCutoffDate)\n          )),\n        'cleanup failed notifications'\n      );\n      \n      // Update stale pending notifications (older than 24 hours) to failed\n      const staleCutoffDate = new Date();\n      staleCutoffDate.setHours(staleCutoffDate.getHours() - 24);\n      \n      const staleResult = await this.executeWithRetry(\n        () => this.db\n          .update(paymentNotifications)\n          .set({ \n            status: 'failed',\n            sentAt: new Date()\n          })\n          .where(and(\n            eq(paymentNotifications.status, 'pending'),\n            lte(paymentNotifications.scheduledFor, staleCutoffDate)\n          )),\n        'update stale notifications'\n      );\n      \n      cleanedCount = ((sentResult as any)?.rowCount || 0) + ((failedResult as any)?.rowCount || 0) + ((staleResult as any)?.rowCount || 0);\n      \n      const duration = Date.now() - startTime;\n      this.logger.log(`Notification cleanup completed: ${cleanedCount} notifications processed, ${duration}ms`);\n      \n      this.logOperationMetrics('notification_cleanup', {\n        processed: cleanedCount,\n        errors: errorCount,\n        duration,\n        success: true,\n        details: {\n          sentCleaned: (sentResult as any)?.rowCount || 0,\n          failedCleaned: (failedResult as any)?.rowCount || 0,\n          staleUpdated: (staleResult as any)?.rowCount || 0\n        }\n      });\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.error(`Critical error during notification cleanup: ${error.message}`, error.stack);\n      \n      this.logOperationMetrics('notification_cleanup', {\n        processed: cleanedCount,\n        errors: errorCount + 1,\n        duration,\n        success: false,\n        criticalError: error.message\n      });\n    }\n  }\n\n  /**\n   * Execute operation with retry mechanism for failed operations\n   */\n  private async executeWithRetry<T>(\n    operation: () => Promise<T>,\n    operationName: string,\n    retries: number = this.maxRetries\n  ): Promise<T> {\n    let lastError: Error | null = null;\n    \n    for (let attempt = 1; attempt <= retries; attempt++) {\n      try {\n        this.logger.debug(`Executing ${operationName} (attempt ${attempt}/${retries})`);\n        const result = await operation();\n        \n        if (attempt > 1) {\n          this.logger.log(`${operationName} succeeded on attempt ${attempt}`);\n        }\n        \n        return result;\n      } catch (error) {\n        lastError = error;\n        this.logger.warn(`${operationName} failed on attempt ${attempt}: ${error.message}`);\n        \n        if (attempt < retries) {\n          const delay = this.retryDelay * attempt; // Exponential backoff\n          this.logger.log(`Retrying ${operationName} in ${delay}ms...`);\n          await this.sleep(delay);\n        }\n      }\n    }\n    \n    this.logger.error(`${operationName} failed after ${retries} attempts`);\n    throw lastError || new Error(`${operationName} failed`);\n  }\n\n  /**\n   * Sleep utility for retry delays\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Log operation metrics for monitoring and alerting\n   */\n  private logOperationMetrics(operation: string, metrics: {\n    processed: number;\n    errors: number;\n    duration: number;\n    success: boolean;\n    criticalError?: string;\n    details?: any;\n  }): void {\n    const logLevel = metrics.success ? 'log' : 'error';\n    const message = `[METRICS] ${operation}: ${JSON.stringify(metrics)}`;\n    \n    this.logger[logLevel](message);\n    \n    // In a production environment, this could also:\n    // 1. Send metrics to monitoring systems (Prometheus, DataDog, etc.)\n    // 2. Trigger alerts for critical errors\n    // 3. Update health check endpoints\n    // 4. Store metrics in time-series database\n  }\n\n  /**\n   * Manual method to trigger escrow release processing (for testing/admin use)\n   */\n  async triggerEscrowReleases(): Promise<void> {\n    this.logger.log('Manual trigger: processing escrow releases...');\n    await this.processEscrowReleases();\n  }\n\n  /**\n   * Manual method to trigger overdue status updates (for testing/admin use)\n   */\n  async triggerOverdueUpdates(): Promise<void> {\n    this.logger.log('Manual trigger: updating overdue payment statuses...');\n    await this.updateOverduePaymentStatuses();\n  }\n\n  /**\n   * Manual method to trigger notification cleanup (for testing/admin use)\n   */\n  async triggerNotificationCleanup(): Promise<void> {\n    this.logger.log('Manual trigger: cleaning up notifications...');\n    await this.cleanupNotifications();\n  }\n\n  /**\n   * Get scheduler health status and metrics\n   */\n  async getSchedulerHealth(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    lastOperations: {\n      escrowReleases?: Date;\n      overdueUpdates?: Date;\n      notificationCleanup?: Date;\n      paymentChecks?: Date;\n      paymentReminders?: Date;\n    };\n    metrics: {\n      totalContracts: number;\n      activeContracts: number;\n      overdueContracts: number;\n      pendingNotifications: number;\n    };\n  }> {\n    try {\n      // Get basic contract metrics\n      const [contractStats] = await this.db\n        .select({\n          total: sql<string>`COUNT(*)`,\n          active: sql<string>`COUNT(*) FILTER (WHERE status = 'active')`,\n        })\n        .from(tenantRentContracts);\n\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      const [overdueStats] = await this.db\n        .select({\n          overdue: sql<string>`COUNT(*) FILTER (WHERE next_payment_due < ${today} AND status = 'active')`,\n        })\n        .from(tenantRentContracts);\n\n      const [notificationStats] = await this.db\n        .select({\n          pending: sql<string>`COUNT(*) FILTER (WHERE status = 'pending')`,\n        })\n        .from(paymentNotifications);\n\n      return {\n        status: 'healthy', // Could implement more sophisticated health checks\n        lastOperations: {\n          // These would be tracked in a separate metrics table in production\n        },\n        metrics: {\n          totalContracts: parseInt(contractStats?.total || '0'),\n          activeContracts: parseInt(contractStats?.active || '0'),\n          overdueContracts: parseInt(overdueStats?.overdue || '0'),\n          pendingNotifications: parseInt(notificationStats?.pending || '0'),\n        }\n      };\n    } catch (error) {\n      this.logger.error(`Error getting scheduler health: ${error.message}`, error.stack);\n      return {\n        status: 'unhealthy',\n        lastOperations: {},\n        metrics: {\n          totalContracts: 0,\n          activeContracts: 0,\n          overdueContracts: 0,\n          pendingNotifications: 0,\n        }\n      };\n    }\n  }\n}"],"names":["SchedulerService","checkDuePayments","logger","log","today","Date","setHours","contractsWithDuePayments","tenantPaymentService","getContractsWithDuePayments","length","contract","dueDate","nextPaymentDue","daysOverdue","Math","floor","getTime","id","toDateString","tenantId","warn","error","sendPaymentReminders","reminderDate","setDate","getDate","contractsWithUpcomingPayments","upcomingOnly","filter","sendPaymentReminderNotification","type","daysUntilDue","ceil","subject","urgencyLevel","abs","toUpperCase","monthlyAmount","sendExpoNotification","title","message","debug","sendEmailNotification","triggerPaymentDueCheck","triggerPaymentReminders","getPaymentDueSummary","totalDue","totalOverdue","contractsWithOverduePayments","amount","parseFloat","processEscrowReleases","startTime","now","processedCount","errorCount","results","executeWithRetry","landlordPayoutService","checkEscrowReleases","result","success","releasedAmount","landlordId","escrowId","duration","logOperationMetrics","processed","errors","stack","criticalError","updateOverduePaymentStatuses","updatedCount","overdueContracts","db","select","from","tenantRentContracts","where","and","lte","eq","status","cleanupNotifications","cleanedCount","cutoffDate","sentResult","delete","paymentNotifications","sentAt","failedCutoffDate","failedResult","createdAt","staleCutoffDate","getHours","staleResult","update","set","scheduledFor","rowCount","details","sentCleaned","failedCleaned","staleUpdated","operation","operationName","retries","maxRetries","lastError","attempt","delay","retryDelay","sleep","Error","ms","Promise","resolve","setTimeout","metrics","logLevel","JSON","stringify","triggerEscrowReleases","triggerOverdueUpdates","triggerNotificationCleanup","getSchedulerHealth","contractStats","total","sql","active","overdueStats","overdue","notificationStats","pending","lastOperations","totalContracts","parseInt","activeContracts","pendingNotifications","emailService","Logger","name","EVERY_DAY_AT_9AM"],"mappings":"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"}