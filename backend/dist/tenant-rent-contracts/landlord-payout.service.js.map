{"version":3,"sources":["../../src/tenant-rent-contracts/landlord-payout.service.ts"],"sourcesContent":["import { Injectable, Inject, Logger } from '@nestjs/common';\nimport { eq, and, lte, sql } from 'drizzle-orm';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport { \n  landlordEscrowBalances, \n  tenantRentContracts,\n  users,\n  LandlordEscrowBalance,\n  NewLandlordEscrowBalance,\n  TenantRentContract\n} from '../database/schema';\n\nexport interface PayoutResult {\n  success: boolean;\n  payoutType: 'immediate' | 'escrow';\n  amount: number;\n  transactionId?: string;\n}\n\nexport interface EscrowReleaseResult {\n  success: boolean;\n  releasedAmount: number;\n  escrowId: string;\n  landlordId: string;\n}\n\n@Injectable()\nexport class LandlordPayoutService {\n  private readonly logger = new Logger(LandlordPayoutService.name);\n\n  constructor(\n    @Inject(DATABASE_CONNECTION) private readonly db: any,\n  ) {}\n\n  /**\n   * Process immediate payout for monthly landlords\n   * Credits the landlord's wallet immediately when tenant pays\n   */\n  async processImmediatePayout(\n    landlordId: string, \n    amount: number, \n    contractId: string\n  ): Promise<PayoutResult> {\n    try {\n      this.logger.log(`Processing immediate payout: ${amount} for landlord ${landlordId}, contract ${contractId}`);\n\n      // Validate contract exists and belongs to landlord\n      const [contract] = await this.db\n        .select()\n        .from(tenantRentContracts)\n        .where(and(\n          eq(tenantRentContracts.id, contractId),\n          eq(tenantRentContracts.landlordId, landlordId),\n          eq(tenantRentContracts.landlordPayoutType, 'monthly')\n        ));\n\n      if (!contract) {\n        throw new Error(`Contract not found or not eligible for immediate payout: ${contractId}`);\n      }\n\n      // TODO: Integrate with existing wallet/payment system to credit landlord\n      // For now, we'll log the transaction - this should be replaced with actual wallet credit\n      this.logger.log(`Would credit landlord ${landlordId} wallet with ${amount} for contract ${contractId}`);\n\n      // In a real implementation, this would:\n      // 1. Credit the landlord's wallet balance\n      // 2. Create a transaction record\n      // 3. Send notification to landlord\n      \n      return {\n        success: true,\n        payoutType: 'immediate',\n        amount,\n        transactionId: `txn_${Date.now()}_${contractId}` // Mock transaction ID\n      };\n    } catch (error) {\n      this.logger.error(`Error processing immediate payout: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Add payment to escrow for yearly payout accumulation\n   * Stores tenant payments until contract expiry or 12 months\n   */\n  async addToEscrow(\n    landlordId: string, \n    amount: number, \n    contractId: string\n  ): Promise<PayoutResult> {\n    try {\n      this.logger.log(`Adding to escrow: ${amount} for landlord ${landlordId}, contract ${contractId}`);\n\n      // Validate contract exists and belongs to landlord\n      const [contract] = await this.db\n        .select()\n        .from(tenantRentContracts)\n        .where(and(\n          eq(tenantRentContracts.id, contractId),\n          eq(tenantRentContracts.landlordId, landlordId),\n          eq(tenantRentContracts.landlordPayoutType, 'yearly')\n        ));\n\n      if (!contract) {\n        throw new Error(`Contract not found or not eligible for escrow: ${contractId}`);\n      }\n\n      // Check if escrow balance already exists for this contract\n      const [existingEscrow] = await this.db\n        .select()\n        .from(landlordEscrowBalances)\n        .where(and(\n          eq(landlordEscrowBalances.contractId, contractId),\n          eq(landlordEscrowBalances.isReleased, false)\n        ));\n\n      if (existingEscrow) {\n        // Update existing escrow balance\n        const newTotal = parseFloat(existingEscrow.totalEscrowed) + amount;\n        const newMonthsAccumulated = existingEscrow.monthsAccumulated + 1;\n\n        await this.db\n          .update(landlordEscrowBalances)\n          .set({\n            totalEscrowed: newTotal.toString(),\n            monthsAccumulated: newMonthsAccumulated,\n            updatedAt: new Date(),\n          })\n          .where(eq(landlordEscrowBalances.id, existingEscrow.id));\n\n        this.logger.log(`Updated escrow balance: ${newTotal} (${newMonthsAccumulated} months) for contract ${contractId}`);\n      } else {\n        // Create new escrow balance\n        const expectedReleaseDate = new Date(contract.expiryDate);\n        \n        const newEscrow: NewLandlordEscrowBalance = {\n          landlordId,\n          contractId,\n          totalEscrowed: amount.toString(),\n          monthsAccumulated: 1,\n          expectedReleaseDate,\n          isReleased: false,\n        };\n\n        await this.db\n          .insert(landlordEscrowBalances)\n          .values(newEscrow);\n\n        this.logger.log(`Created new escrow balance: ${amount} for contract ${contractId}, release date: ${expectedReleaseDate}`);\n      }\n\n      return {\n        success: true,\n        payoutType: 'escrow',\n        amount,\n      };\n    } catch (error) {\n      this.logger.error(`Error adding to escrow: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Check for escrow balances ready for release\n   * Called by scheduler to process contract expiries\n   */\n  async checkEscrowReleases(): Promise<EscrowReleaseResult[]> {\n    try {\n      this.logger.log('Checking for escrow balances ready for release');\n\n      const today = new Date();\n      \n      // Find escrow balances that are ready for release (past expected release date)\n      const readyForRelease = await this.db\n        .select({\n          escrow: landlordEscrowBalances,\n          contract: tenantRentContracts,\n        })\n        .from(landlordEscrowBalances)\n        .leftJoin(tenantRentContracts, eq(landlordEscrowBalances.contractId, tenantRentContracts.id))\n        .where(and(\n          eq(landlordEscrowBalances.isReleased, false),\n          lte(landlordEscrowBalances.expectedReleaseDate, today)\n        ));\n\n      this.logger.log(`Found ${readyForRelease.length} escrow balances ready for release`);\n\n      const results: EscrowReleaseResult[] = [];\n\n      for (const item of readyForRelease) {\n        try {\n          const result = await this.releaseEscrowBalance(item.escrow.id);\n          results.push(result);\n        } catch (error) {\n          this.logger.error(`Failed to release escrow ${item.escrow.id}: ${error.message}`);\n          // Continue with other releases even if one fails\n        }\n      }\n\n      return results;\n    } catch (error) {\n      this.logger.error(`Error checking escrow releases: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Release escrow balance with transaction safety\n   * Transfers accumulated escrow to landlord's wallet\n   */\n  async releaseEscrowBalance(escrowId: string): Promise<EscrowReleaseResult> {\n    try {\n      this.logger.log(`Releasing escrow balance: ${escrowId}`);\n\n      // Use transaction for safety\n      return await this.db.transaction(async (tx: any) => {\n        // Get escrow balance details\n        const [escrow] = await tx\n          .select()\n          .from(landlordEscrowBalances)\n          .where(and(\n            eq(landlordEscrowBalances.id, escrowId),\n            eq(landlordEscrowBalances.isReleased, false)\n          ));\n\n        if (!escrow) {\n          throw new Error(`Escrow balance not found or already released: ${escrowId}`);\n        }\n\n        const releaseAmount = parseFloat(escrow.totalEscrowed);\n        \n        if (releaseAmount <= 0) {\n          throw new Error(`Invalid release amount: ${releaseAmount}`);\n        }\n\n        // TODO: Credit landlord's wallet with the escrow amount\n        // This should integrate with the existing wallet/payment system\n        this.logger.log(`Would credit landlord ${escrow.landlordId} wallet with ${releaseAmount} from escrow ${escrowId}`);\n\n        // Mark escrow as released\n        await tx\n          .update(landlordEscrowBalances)\n          .set({\n            isReleased: true,\n            releasedAt: new Date(),\n            releasedAmount: releaseAmount.toString(),\n            updatedAt: new Date(),\n          })\n          .where(eq(landlordEscrowBalances.id, escrowId));\n\n        this.logger.log(`Successfully released escrow: ${releaseAmount} to landlord ${escrow.landlordId}`);\n\n        return {\n          success: true,\n          releasedAmount: releaseAmount,\n          escrowId,\n          landlordId: escrow.landlordId,\n        };\n      });\n    } catch (error) {\n      this.logger.error(`Error releasing escrow balance: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Get landlord's escrow balances\n   * Returns all escrow balances for a landlord (both active and released)\n   */\n  async getLandlordEscrowBalances(landlordId: string): Promise<LandlordEscrowBalance[]> {\n    try {\n      this.logger.log(`Getting escrow balances for landlord: ${landlordId}`);\n\n      const escrowBalances = await this.db\n        .select({\n          escrow: landlordEscrowBalances,\n          contract: tenantRentContracts,\n        })\n        .from(landlordEscrowBalances)\n        .leftJoin(tenantRentContracts, eq(landlordEscrowBalances.contractId, tenantRentContracts.id))\n        .where(eq(landlordEscrowBalances.landlordId, landlordId));\n\n      this.logger.log(`Found ${escrowBalances.length} escrow balances for landlord ${landlordId}`);\n\n      return escrowBalances.map(item => ({\n        ...item.escrow,\n        contract: item.contract,\n      })) as any;\n    } catch (error) {\n      this.logger.error(`Error getting landlord escrow balances: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Get total escrowed amount for a landlord\n   * Returns sum of all active (unreleased) escrow balances\n   */\n  async getTotalEscrowedAmount(landlordId: string): Promise<number> {\n    try {\n      this.logger.log(`Getting total escrowed amount for landlord: ${landlordId}`);\n\n      const [result] = await this.db\n        .select({\n          total: sql<string>`COALESCE(SUM(${landlordEscrowBalances.totalEscrowed}), 0)`,\n        })\n        .from(landlordEscrowBalances)\n        .where(and(\n          eq(landlordEscrowBalances.landlordId, landlordId),\n          eq(landlordEscrowBalances.isReleased, false)\n        ));\n\n      const totalAmount = parseFloat(result?.total || '0');\n      \n      this.logger.log(`Total escrowed amount for landlord ${landlordId}: ${totalAmount}`);\n      \n      return totalAmount;\n    } catch (error) {\n      this.logger.error(`Error getting total escrowed amount: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Get escrow balance by contract ID\n   * Helper method to get escrow details for a specific contract\n   */\n  async getEscrowByContractId(contractId: string): Promise<LandlordEscrowBalance | null> {\n    try {\n      const [escrow] = await this.db\n        .select()\n        .from(landlordEscrowBalances)\n        .where(and(\n          eq(landlordEscrowBalances.contractId, contractId),\n          eq(landlordEscrowBalances.isReleased, false)\n        ));\n\n      return escrow || null;\n    } catch (error) {\n      this.logger.error(`Error getting escrow by contract ID: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Force release escrow balance (for early contract termination)\n   * Allows manual release of escrow before expected date\n   */\n  async forceReleaseEscrow(contractId: string, reason?: string): Promise<EscrowReleaseResult> {\n    try {\n      this.logger.log(`Force releasing escrow for contract: ${contractId}, reason: ${reason}`);\n\n      const escrow = await this.getEscrowByContractId(contractId);\n      \n      if (!escrow) {\n        throw new Error(`No active escrow found for contract: ${contractId}`);\n      }\n\n      // Log the reason for force release\n      this.logger.log(`Force releasing escrow ${escrow.id} for reason: ${reason || 'Manual release'}`);\n\n      return await this.releaseEscrowBalance(escrow.id);\n    } catch (error) {\n      this.logger.error(`Error force releasing escrow: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n}"],"names":["LandlordPayoutService","processImmediatePayout","landlordId","amount","contractId","logger","log","contract","db","select","from","tenantRentContracts","where","and","eq","id","landlordPayoutType","Error","success","payoutType","transactionId","Date","now","error","message","stack","addToEscrow","existingEscrow","landlordEscrowBalances","isReleased","newTotal","parseFloat","totalEscrowed","newMonthsAccumulated","monthsAccumulated","update","set","toString","updatedAt","expectedReleaseDate","expiryDate","newEscrow","insert","values","checkEscrowReleases","today","readyForRelease","escrow","leftJoin","lte","length","results","item","result","releaseEscrowBalance","push","escrowId","transaction","tx","releaseAmount","releasedAt","releasedAmount","getLandlordEscrowBalances","escrowBalances","map","getTotalEscrowedAmount","total","sql","totalAmount","getEscrowByContractId","forceReleaseEscrow","reason","Logger","name"],"mappings":"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"}