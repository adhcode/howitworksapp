{"version":3,"sources":["../../src/tenant-rent-contracts/tenant-payment.service.ts"],"sourcesContent":["import { Injectable, Inject, NotFoundException, BadRequestException } from '@nestjs/common';\nimport { eq, and, or } from 'drizzle-orm';\nimport { PostgresJsDatabase } from 'drizzle-orm/postgres-js';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport * as schema from '../database/schema';\nimport { \n  CreateRentContractDto, \n  ContractQueryDto, \n  LandlordPayoutType,\n  ContractStatus \n} from './dto/tenant-rent-contract.dto';\nimport { \n  TenantRentContract, \n  NewTenantRentContract,\n  tenantRentContracts,\n  LandlordEscrowBalance,\n  NewLandlordEscrowBalance,\n  landlordEscrowBalances\n} from '../database/schema/tenant-rent-contracts';\nimport { payments, NewPayment } from '../database/schema/payments';\n\nexport interface PaymentResult {\n  success: boolean;\n  payoutType: LandlordPayoutType;\n  message: string;\n  nextPaymentDue: Date;\n}\n\n@Injectable()\nexport class TenantPaymentService {\n  constructor(\n    @Inject(DATABASE_CONNECTION)\n    private readonly db: PostgresJsDatabase<typeof schema>,\n  ) {}\n\n  /**\n   * Calculate transition start date based on tenant type\n   * NEW TENANT: Start immediately (today)\n   * EXISTING TENANT: Start 6 months before current contract expires\n   */\n  calculateTransitionStartDate(\n    isExistingTenant: boolean,\n    originalExpiryDate: Date | null,\n    newExpiryDate: Date\n  ): Date {\n    // NEW TENANT: Start immediately (today)\n    if (!isExistingTenant) {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      return today;\n    }\n    \n    // EXISTING TENANT: Start 6 months before current contract expires\n    if (!originalExpiryDate) {\n      throw new BadRequestException('Original expiry date is required for existing tenants');\n    }\n    \n    const transitionDate = new Date(originalExpiryDate);\n    transitionDate.setMonth(transitionDate.getMonth() - 6);\n    transitionDate.setHours(0, 0, 0, 0);\n    \n    return transitionDate;\n  }\n\n  /**\n   * Calculate arrears for existing tenants who are overdue\n   * Returns months overdue, total arrears amount, and next payment due date\n   */\n  calculateArrears(\n    transitionStartDate: Date,\n    monthlyAmount: number\n  ): {\n    monthsOverdue: number;\n    totalArrears: number;\n    nextPaymentDue: Date;\n  } {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    const transition = new Date(transitionStartDate);\n    transition.setHours(0, 0, 0, 0);\n    \n    // If transition date is in the future, no arrears\n    if (transition >= today) {\n      return {\n        monthsOverdue: 0,\n        totalArrears: 0,\n        nextPaymentDue: transition\n      };\n    }\n    \n    // Calculate months overdue\n    let monthsOverdue = 0;\n    let checkDate = new Date(transition);\n    \n    while (checkDate < today) {\n      monthsOverdue++;\n      checkDate.setMonth(checkDate.getMonth() + 1);\n    }\n    \n    // Total arrears = months × monthly rent\n    const totalArrears = monthsOverdue * monthlyAmount;\n    \n    // Next payment due is the first day of next month\n    const nextPaymentDue = new Date(today);\n    nextPaymentDue.setMonth(nextPaymentDue.getMonth() + 1);\n    nextPaymentDue.setDate(1);\n    nextPaymentDue.setHours(0, 0, 0, 0);\n    \n    return {\n      monthsOverdue,\n      totalArrears,\n      nextPaymentDue\n    };\n  }\n\n  /**\n   * Calculate first payment due date based on transition start date\n   */\n  private calculateFirstPaymentDue(transitionStartDate: Date): Date {\n    // First payment is due on the transition start date\n    return new Date(transitionStartDate);\n  }\n\n  /**\n   * Validate contract creation data\n   */\n  private async validateContractCreation(dto: CreateRentContractDto): Promise<void> {\n    const expiryDate = new Date(dto.expiryDate);\n    const today = new Date();\n    \n    // Check if expiry date is in the future\n    if (expiryDate <= today) {\n      throw new BadRequestException('Contract expiry date must be in the future');\n    }\n\n    // For existing tenants, validate original expiry date\n    if (dto.isExistingTenant) {\n      if (!dto.originalExpiryDate) {\n        throw new BadRequestException('Original expiry date is required for existing tenants');\n      }\n      \n      const originalExpiry = new Date(dto.originalExpiryDate);\n      if (originalExpiry <= today) {\n        throw new BadRequestException('Original expiry date must be in the future for existing tenants');\n      }\n    }\n\n    // Check if tenant already has an active contract\n    const existingContract = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(\n        and(\n          eq(tenantRentContracts.tenantId, dto.tenantId),\n          eq(tenantRentContracts.status, 'active')\n        )\n      )\n      .limit(1);\n\n    if (existingContract.length > 0) {\n      throw new BadRequestException('Tenant already has an active rent contract');\n    }\n\n    // Validate monthly amount\n    if (dto.monthlyAmount <= 0) {\n      throw new BadRequestException('Monthly amount must be greater than 0');\n    }\n  }\n\n  /**\n   * Create a new rent contract with business logic validation\n   * Returns contract and arrears info if tenant is overdue\n   */\n  async createRentContract(dto: CreateRentContractDto): Promise<{\n    contract: TenantRentContract;\n    arrears?: {\n      monthsOverdue: number;\n      totalArrears: number;\n      message: string;\n    };\n  }> {\n    // Validate the contract data\n    await this.validateContractCreation(dto);\n\n    const expiryDate = new Date(dto.expiryDate);\n    \n    // Calculate transition start based on tenant type\n    const transitionStartDate = this.calculateTransitionStartDate(\n      dto.isExistingTenant,\n      dto.originalExpiryDate ? new Date(dto.originalExpiryDate) : null,\n      expiryDate\n    );\n    \n    // Calculate arrears if existing tenant is overdue\n    let arrearsInfo: {\n      monthsOverdue: number;\n      totalArrears: number;\n      message: string;\n    } | undefined = undefined;\n    let nextPaymentDue = transitionStartDate;\n    \n    if (dto.isExistingTenant) {\n      const arrears = this.calculateArrears(\n        transitionStartDate,\n        dto.monthlyAmount\n      );\n      \n      if (arrears.monthsOverdue > 0) {\n        arrearsInfo = {\n          monthsOverdue: arrears.monthsOverdue,\n          totalArrears: arrears.totalArrears,\n          message: `Tenant owes ${arrears.monthsOverdue} month${arrears.monthsOverdue > 1 ? 's' : ''} rent (₦${arrears.totalArrears.toLocaleString()}). Must pay arrears before continuing.`\n        };\n        \n        // Next payment is calculated from arrears\n        nextPaymentDue = arrears.nextPaymentDue;\n      }\n    }\n\n    const newContract: NewTenantRentContract = {\n      tenantId: dto.tenantId,\n      landlordId: dto.landlordId,\n      propertyId: dto.propertyId,\n      unitId: dto.unitId,\n      monthlyAmount: dto.monthlyAmount.toString(),\n      expiryDate,\n      landlordPayoutType: dto.landlordPayoutType,\n      nextPaymentDue,\n      transitionStartDate,\n      status: 'active',\n      isExistingTenant: dto.isExistingTenant,\n      originalExpiryDate: dto.originalExpiryDate ? new Date(dto.originalExpiryDate) : null,\n    };\n\n    const [createdContract] = await this.db\n      .insert(tenantRentContracts)\n      .values(newContract)\n      .returning();\n\n    if (!createdContract) {\n      throw new BadRequestException('Failed to create rent contract');\n    }\n\n    return {\n      contract: createdContract,\n      arrears: arrearsInfo\n    };\n  }\n\n  /**\n   * Get active contracts with optional filtering\n   */\n  async getActiveContracts(tenantId?: string, landlordId?: string): Promise<TenantRentContract[]> {\n    const query: ContractQueryDto = {};\n    if (tenantId) query.tenantId = tenantId;\n    if (landlordId) query.landlordId = landlordId;\n    \n    return this.getActiveContractsWithQuery(query);\n  }\n\n  /**\n   * Get active contracts with query object\n   */\n  async getActiveContractsWithQuery(query?: ContractQueryDto): Promise<TenantRentContract[]> {\n    let whereConditions = [eq(tenantRentContracts.status, 'active')];\n\n    if (query?.tenantId) {\n      whereConditions.push(eq(tenantRentContracts.tenantId, query.tenantId));\n    }\n\n    if (query?.landlordId) {\n      whereConditions.push(eq(tenantRentContracts.landlordId, query.landlordId));\n    }\n\n    if (query?.propertyId) {\n      whereConditions.push(eq(tenantRentContracts.propertyId, query.propertyId));\n    }\n\n    const contracts = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(and(...whereConditions))\n      .orderBy(tenantRentContracts.createdAt);\n\n    return contracts;\n  }\n\n  /**\n   * Get all contracts (active, expired, terminated) with optional filtering\n   */\n  async getAllContracts(query?: ContractQueryDto): Promise<TenantRentContract[]> {\n    let whereConditions: any[] = [];\n\n    if (query?.tenantId) {\n      whereConditions.push(eq(tenantRentContracts.tenantId, query.tenantId));\n    }\n\n    if (query?.landlordId) {\n      whereConditions.push(eq(tenantRentContracts.landlordId, query.landlordId));\n    }\n\n    if (query?.propertyId) {\n      whereConditions.push(eq(tenantRentContracts.propertyId, query.propertyId));\n    }\n\n    if (query?.status) {\n      whereConditions.push(eq(tenantRentContracts.status, query.status));\n    }\n\n    const queryBuilder = this.db\n      .select()\n      .from(tenantRentContracts)\n      .orderBy(tenantRentContracts.createdAt);\n\n    if (whereConditions.length > 0) {\n      return await queryBuilder.where(and(...whereConditions));\n    }\n\n    return await queryBuilder;\n  }\n\n  /**\n   * Get contract by ID\n   */\n  async getContractById(contractId: string): Promise<TenantRentContract> {\n    const [contract] = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(eq(tenantRentContracts.id, contractId))\n      .limit(1);\n\n    if (!contract) {\n      throw new NotFoundException(`Rent contract not found: ${contractId}`);\n    }\n\n    return contract;\n  }\n\n  /**\n   * Update next payment due date (typically called after successful payment)\n   */\n  async updateNextPaymentDue(contractId: string): Promise<void> {\n    const contract = await this.getContractById(contractId);\n    \n    // Calculate next payment due (add 1 month to current due date)\n    const nextDue = new Date(contract.nextPaymentDue);\n    nextDue.setMonth(nextDue.getMonth() + 1);\n\n    // Ensure we don't schedule payments beyond contract expiry\n    const expiryDate = new Date(contract.expiryDate);\n    if (nextDue > expiryDate) {\n      // If next payment would be after expiry, mark contract as expired\n      await this.updateContractStatus(contractId, ContractStatus.EXPIRED);\n      return;\n    }\n\n    await this.db\n      .update(tenantRentContracts)\n      .set({ \n        nextPaymentDue: nextDue,\n        updatedAt: new Date()\n      })\n      .where(eq(tenantRentContracts.id, contractId));\n  }\n\n  /**\n   * Get contracts with payments due (for scheduler use)\n   */\n  async getContractsWithDuePayments(asOfDate?: Date): Promise<TenantRentContract[]> {\n    const checkDate = asOfDate || new Date();\n    \n    const contracts = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(\n        and(\n          eq(tenantRentContracts.status, 'active'),\n          // Payment is due if nextPaymentDue <= checkDate\n          // Using string comparison since Drizzle handles date comparison\n        )\n      )\n      .orderBy(tenantRentContracts.nextPaymentDue);\n\n    // Filter in JavaScript for more precise date comparison\n    return contracts.filter(contract => \n      new Date(contract.nextPaymentDue) <= checkDate\n    );\n  }\n\n  /**\n   * Update contract status\n   */\n  async updateContractStatus(contractId: string, status: ContractStatus): Promise<TenantRentContract> {\n    const contract = await this.getContractById(contractId);\n\n    const [updatedContract] = await this.db\n      .update(tenantRentContracts)\n      .set({ \n        status,\n        updatedAt: new Date()\n      })\n      .where(eq(tenantRentContracts.id, contractId))\n      .returning();\n\n    if (!updatedContract) {\n      throw new BadRequestException('Failed to update contract status');\n    }\n\n    return updatedContract;\n  }\n\n  /**\n   * Get contracts expiring soon (for escrow release checks)\n   */\n  async getExpiringContracts(daysAhead: number = 7): Promise<TenantRentContract[]> {\n    const checkDate = new Date();\n    checkDate.setDate(checkDate.getDate() + daysAhead);\n\n    const contracts = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(\n        and(\n          eq(tenantRentContracts.status, 'active'),\n          eq(tenantRentContracts.landlordPayoutType, 'yearly')\n        )\n      )\n      .orderBy(tenantRentContracts.expiryDate);\n\n    // Filter contracts expiring within the specified timeframe\n    return contracts.filter(contract => \n      new Date(contract.expiryDate) <= checkDate\n    );\n  }\n\n  /**\n   * Process monthly payment with payout type routing\n   * Routes payment to immediate payout or escrow based on landlord preference\n   * Handles arrears payments for overdue existing tenants\n   */\n  async processMonthlyPayment(contractId: string, amount: number, paymentMethod?: string, reference?: string): Promise<PaymentResult> {\n    // Validate inputs\n    if (amount <= 0) {\n      throw new BadRequestException('Payment amount must be greater than 0');\n    }\n\n    // Get the contract\n    const contract = await this.getContractById(contractId);\n\n    // Check if tenant has arrears\n    const arrears = this.calculateArrears(\n      contract.transitionStartDate,\n      parseFloat(contract.monthlyAmount)\n    );\n    \n    if (arrears.monthsOverdue > 0) {\n      // Tenant must pay arrears first\n      if (amount < arrears.totalArrears) {\n        throw new BadRequestException(\n          `You have ${arrears.monthsOverdue} month${arrears.monthsOverdue > 1 ? 's' : ''} arrears (₦${arrears.totalArrears.toLocaleString()}). Please pay full arrears amount of ₦${arrears.totalArrears.toLocaleString()}.`\n        );\n      }\n      \n      // Process arrears payment\n      return this.processArrearsPayment(contract, amount, arrears, paymentMethod, reference);\n    }\n\n    // Normal monthly payment validation\n    const expectedAmount = parseFloat(contract.monthlyAmount);\n    if (Math.abs(amount - expectedAmount) > 0.01) { // Allow for small floating point differences\n      throw new BadRequestException(\n        `Payment amount ₦${amount.toLocaleString()} does not match expected monthly amount ₦${expectedAmount.toLocaleString()}`\n      );\n    }\n\n    // Check if payment is due (allow payments up to 30 days early)\n    const today = new Date();\n    const paymentDue = new Date(contract.nextPaymentDue);\n    \n    const earliestPaymentDate = new Date(paymentDue);\n    earliestPaymentDate.setDate(earliestPaymentDate.getDate() - 30);\n    \n    if (today < earliestPaymentDate) {\n      throw new BadRequestException(\n        `Payment is too early. Next payment due on ${paymentDue.toDateString()}`\n      );\n    }\n\n    try {\n      // Start a transaction-like operation\n      let payoutMessage: string;\n      \n      if (contract.landlordPayoutType === LandlordPayoutType.MONTHLY) {\n        // Process immediate payout to landlord\n        await this.processImmediatePayout(contract.landlordId, amount, contractId, paymentMethod, reference);\n        payoutMessage = 'Payment credited immediately to landlord wallet';\n      } else {\n        // Add to escrow for yearly release\n        await this.addToEscrow(contract.landlordId, amount, contractId);\n        payoutMessage = 'Payment added to escrow for yearly release';\n      }\n\n      // Create payment record in payments table\n      await this.createPaymentRecord(contract, amount, paymentMethod, reference);\n\n      // Update next payment due date\n      await this.updateNextPaymentDue(contractId);\n\n      return {\n        success: true,\n        payoutType: contract.landlordPayoutType as LandlordPayoutType,\n        message: payoutMessage,\n        nextPaymentDue: new Date(contract.nextPaymentDue.getTime() + (30 * 24 * 60 * 60 * 1000)) // Add 1 month\n      };\n\n    } catch (error) {\n      console.error('Error processing monthly payment:', error);\n      throw new BadRequestException(`Failed to process payment: ${error.message}`);\n    }\n  }\n\n  /**\n   * Process arrears payment for overdue existing tenants\n   */\n  private async processArrearsPayment(\n    contract: TenantRentContract,\n    amount: number,\n    arrears: { monthsOverdue: number; totalArrears: number; nextPaymentDue: Date },\n    paymentMethod?: string,\n    reference?: string\n  ): Promise<PaymentResult> {\n    try {\n      // Route payment based on landlord payout type\n      let payoutMessage: string;\n      \n      if (contract.landlordPayoutType === LandlordPayoutType.MONTHLY) {\n        await this.processImmediatePayout(\n          contract.landlordId,\n          amount,\n          contract.id,\n          paymentMethod,\n          reference\n        );\n        payoutMessage = 'Arrears payment credited immediately to landlord';\n      } else {\n        await this.addToEscrow(contract.landlordId, amount, contract.id);\n        payoutMessage = 'Arrears payment added to escrow';\n      }\n      \n      // Create payment record for arrears\n      await this.createArrearsPaymentRecord(contract, amount, arrears.monthsOverdue, paymentMethod, reference);\n      \n      // Update next payment due to next month\n      await this.db\n        .update(tenantRentContracts)\n        .set({\n          nextPaymentDue: arrears.nextPaymentDue,\n          updatedAt: new Date()\n        })\n        .where(eq(tenantRentContracts.id, contract.id));\n      \n      return {\n        success: true,\n        payoutType: contract.landlordPayoutType as LandlordPayoutType,\n        message: `Arrears payment of ${arrears.monthsOverdue} month${arrears.monthsOverdue > 1 ? 's' : ''} (₦${amount.toLocaleString()}) processed successfully. ${payoutMessage}. Next payment due: ${arrears.nextPaymentDue.toDateString()}`,\n        nextPaymentDue: arrears.nextPaymentDue\n      };\n    } catch (error) {\n      console.error('Error processing arrears payment:', error);\n      throw new BadRequestException(`Failed to process arrears payment: ${error.message}`);\n    }\n  }\n\n  /**\n   * Create payment record for arrears\n   */\n  private async createArrearsPaymentRecord(\n    contract: TenantRentContract,\n    amount: number,\n    monthsOverdue: number,\n    paymentMethod?: string,\n    reference?: string\n  ): Promise<void> {\n    const paymentRecord: NewPayment = {\n      landlordId: contract.landlordId,\n      tenantId: contract.tenantId,\n      propertyId: contract.propertyId,\n      unitId: contract.unitId,\n      tenantInvitationId: '', // This would need to be derived from the contract or made optional\n      amount: amount.toString(),\n      amountPaid: amount.toString(),\n      dueDate: contract.transitionStartDate,\n      paidDate: new Date(),\n      paymentType: 'rent',\n      paymentMethod: (paymentMethod as any) || 'online',\n      status: 'paid',\n      description: `Arrears payment for ${monthsOverdue} month${monthsOverdue > 1 ? 's' : ''} overdue rent`,\n      notes: reference ? `Payment reference: ${reference}. Arrears cleared.` : 'Arrears cleared.',\n    };\n\n    console.log(`Created arrears payment record for contract ${contract.id}: ${monthsOverdue} months, ₦${amount.toLocaleString()}`);\n  }\n\n  /**\n   * Process immediate payout to landlord wallet (for monthly payout type)\n   */\n  private async processImmediatePayout(landlordId: string, amount: number, contractId: string, paymentMethod?: string, reference?: string): Promise<void> {\n    // For now, we'll create a payment record that indicates immediate payout\n    // In a real system, this would integrate with a wallet service or payment processor\n    \n    // Create a payment record showing the landlord received the payment\n    const paymentRecord: NewPayment = {\n      landlordId,\n      tenantId: '', // Will be filled from contract\n      propertyId: '', // Will be filled from contract  \n      unitId: '', // Will be filled from contract\n      tenantInvitationId: '', // This might need to be optional or derived\n      amount: amount.toString(),\n      amountPaid: amount.toString(),\n      dueDate: new Date(),\n      paidDate: new Date(),\n      paymentType: 'rent',\n      paymentMethod: (paymentMethod as any) || 'online',\n      status: 'paid',\n      description: `Monthly rent payment - immediate payout (Contract: ${contractId})`,\n      notes: `Immediate payout to landlord. Reference: ${reference || 'N/A'}`,\n    };\n\n    // Note: In a production system, this would:\n    // 1. Call a wallet service to credit the landlord's account\n    // 2. Create appropriate transaction records\n    // 3. Handle any payout failures with proper rollback\n    \n    console.log(`Processing immediate payout of ${amount} to landlord ${landlordId} for contract ${contractId}`);\n  }\n\n  /**\n   * Add payment to escrow for yearly payout\n   */\n  private async addToEscrow(landlordId: string, amount: number, contractId: string): Promise<void> {\n    // Check if escrow balance already exists for this contract\n    const [existingEscrow] = await this.db\n      .select()\n      .from(landlordEscrowBalances)\n      .where(\n        and(\n          eq(landlordEscrowBalances.landlordId, landlordId),\n          eq(landlordEscrowBalances.contractId, contractId),\n          eq(landlordEscrowBalances.isReleased, false)\n        )\n      )\n      .limit(1);\n\n    if (existingEscrow) {\n      // Update existing escrow balance\n      const newTotal = parseFloat(existingEscrow.totalEscrowed) + amount;\n      const newMonthsAccumulated = existingEscrow.monthsAccumulated + 1;\n\n      await this.db\n        .update(landlordEscrowBalances)\n        .set({\n          totalEscrowed: newTotal.toString(),\n          monthsAccumulated: newMonthsAccumulated,\n          updatedAt: new Date()\n        })\n        .where(eq(landlordEscrowBalances.id, existingEscrow.id));\n\n      console.log(`Updated escrow balance for contract ${contractId}: ${newTotal} (${newMonthsAccumulated} months)`);\n    } else {\n      // Create new escrow balance\n      const contract = await this.getContractById(contractId);\n      \n      const newEscrow: NewLandlordEscrowBalance = {\n        landlordId,\n        contractId,\n        totalEscrowed: amount.toString(),\n        monthsAccumulated: 1,\n        expectedReleaseDate: contract.expiryDate,\n        isReleased: false\n      };\n\n      await this.db\n        .insert(landlordEscrowBalances)\n        .values(newEscrow);\n\n      console.log(`Created new escrow balance for contract ${contractId}: ${amount}`);\n    }\n  }\n\n  /**\n   * Create payment record in the payments table\n   */\n  private async createPaymentRecord(contract: TenantRentContract, amount: number, paymentMethod?: string, reference?: string): Promise<void> {\n    // Note: This assumes we have a way to get or create a tenant invitation ID\n    // In a real system, this relationship would be properly established\n    \n    const paymentRecord: NewPayment = {\n      landlordId: contract.landlordId,\n      tenantId: contract.tenantId,\n      propertyId: contract.propertyId,\n      unitId: contract.unitId,\n      tenantInvitationId: '', // This would need to be derived from the contract or made optional\n      amount: amount.toString(),\n      amountPaid: amount.toString(),\n      dueDate: contract.nextPaymentDue,\n      paidDate: new Date(),\n      paymentType: 'rent',\n      paymentMethod: (paymentMethod as any) || 'online',\n      status: 'paid',\n      description: `Monthly rent payment for ${contract.nextPaymentDue.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`,\n      notes: reference ? `Payment reference: ${reference}` : undefined,\n    };\n\n    // For now, we'll skip inserting into payments table due to the tenantInvitationId constraint\n    // In a production system, this would be properly handled\n    console.log(`Would create payment record for contract ${contract.id}, amount: ${amount}`);\n  }\n\n  /**\n   * Validate payment amount and timing\n   */\n  private validatePayment(contract: TenantRentContract, amount: number): void {\n    // Validate amount\n    const expectedAmount = parseFloat(contract.monthlyAmount);\n    if (Math.abs(amount - expectedAmount) > 0.01) {\n      throw new BadRequestException(\n        `Payment amount ${amount} does not match expected monthly amount ${expectedAmount}`\n      );\n    }\n\n    // Validate contract is active\n    if (contract.status !== 'active') {\n      throw new BadRequestException(`Cannot process payment for ${contract.status} contract`);\n    }\n\n    // Validate contract hasn't expired\n    const today = new Date();\n    if (new Date(contract.expiryDate) < today) {\n      throw new BadRequestException('Cannot process payment for expired contract');\n    }\n  }\n\n  /**\n   * Get landlord escrow balances\n   */\n  async getLandlordEscrowBalances(landlordId: string, unreleasedOnly: boolean = false): Promise<LandlordEscrowBalance[]> {\n    let whereConditions = [eq(landlordEscrowBalances.landlordId, landlordId)];\n\n    if (unreleasedOnly) {\n      whereConditions.push(eq(landlordEscrowBalances.isReleased, false));\n    }\n\n    const escrowBalances = await this.db\n      .select()\n      .from(landlordEscrowBalances)\n      .where(and(...whereConditions))\n      .orderBy(landlordEscrowBalances.expectedReleaseDate);\n\n    return escrowBalances;\n  }\n\n  /**\n   * Get total escrowed amount for a landlord\n   */\n  async getTotalEscrowedAmount(landlordId: string): Promise<number> {\n    const escrowBalances = await this.getLandlordEscrowBalances(landlordId, true);\n    \n    return escrowBalances.reduce((total, balance) => {\n      return total + parseFloat(balance.totalEscrowed);\n    }, 0);\n  }\n}"],"names":["TenantPaymentService","calculateTransitionStartDate","isExistingTenant","originalExpiryDate","newExpiryDate","today","Date","setHours","BadRequestException","transitionDate","setMonth","getMonth","calculateArrears","transitionStartDate","monthlyAmount","transition","monthsOverdue","totalArrears","nextPaymentDue","checkDate","setDate","calculateFirstPaymentDue","validateContractCreation","dto","expiryDate","originalExpiry","existingContract","db","select","from","tenantRentContracts","where","and","eq","tenantId","status","limit","length","createRentContract","arrearsInfo","undefined","arrears","message","toLocaleString","newContract","landlordId","propertyId","unitId","toString","landlordPayoutType","createdContract","insert","values","returning","contract","getActiveContracts","query","getActiveContractsWithQuery","whereConditions","push","contracts","orderBy","createdAt","getAllContracts","queryBuilder","getContractById","contractId","id","NotFoundException","updateNextPaymentDue","nextDue","updateContractStatus","ContractStatus","EXPIRED","update","set","updatedAt","getContractsWithDuePayments","asOfDate","filter","updatedContract","getExpiringContracts","daysAhead","getDate","processMonthlyPayment","amount","paymentMethod","reference","parseFloat","processArrearsPayment","expectedAmount","Math","abs","paymentDue","earliestPaymentDate","toDateString","payoutMessage","LandlordPayoutType","MONTHLY","processImmediatePayout","addToEscrow","createPaymentRecord","success","payoutType","getTime","error","console","createArrearsPaymentRecord","paymentRecord","tenantInvitationId","amountPaid","dueDate","paidDate","paymentType","description","notes","log","existingEscrow","landlordEscrowBalances","isReleased","newTotal","totalEscrowed","newMonthsAccumulated","monthsAccumulated","newEscrow","expectedReleaseDate","toLocaleDateString","month","year","validatePayment","getLandlordEscrowBalances","unreleasedOnly","escrowBalances","getTotalEscrowedAmount","reduce","total","balance"],"mappings":"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"}