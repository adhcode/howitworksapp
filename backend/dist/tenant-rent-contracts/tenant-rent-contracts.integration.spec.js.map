{"version":3,"sources":["../../src/tenant-rent-contracts/tenant-rent-contracts.integration.spec.ts"],"sourcesContent":["import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { ScheduleModule } from '@nestjs/schedule';\nimport * as request from 'supertest';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { Pool } from 'pg';\nimport { eq, and } from 'drizzle-orm';\n\nimport { TenantRentContractsModule } from './tenant-rent-contracts.module';\nimport { DatabaseModule } from '../database/database.module';\nimport { EmailModule } from '../email/email.module';\nimport { TenantPaymentService } from './tenant-payment.service';\nimport { LandlordPayoutService } from './landlord-payout.service';\nimport { SchedulerService } from './scheduler.service';\n\nimport { \n  tenantRentContracts, \n  landlordEscrowBalances, \n  paymentNotifications,\n  users,\n  properties,\n  units,\n  payments\n} from '../database/schema';\nimport { LandlordPayoutType, ContractStatus } from './dto/tenant-rent-contract.dto';\n\ndescribe('Tenant Rent Contracts Integration Tests', () => {\n  let app: INestApplication;\n  let module: TestingModule;\n  let tenantPaymentService: TenantPaymentService;\n  let landlordPayoutService: LandlordPayoutService;\n  let schedulerService: SchedulerService;\n  \n  let db: any;\n  let pool: Pool;\n  \n  // Test data\n  let testLandlord: any;\n  let testTenant: any;\n  let testProperty: any;\n  let testUnit: any;\n\n  beforeAll(async () => {\n    // Setup test database connection\n    pool = new Pool({\n      connectionString: process.env.DATABASE_URL || 'postgresql://postgres:password@localhost:5432/homezy_test_db',\n    });\n    db = drizzle(pool);\n\n    module = await Test.createTestingModule({\n      imports: [\n        ConfigModule.forRoot({ isGlobal: true }),\n        ScheduleModule.forRoot(),\n        DatabaseModule,\n        EmailModule,\n        TenantRentContractsModule,\n      ],\n    }).compile();\n\n    app = module.createNestApplication();\n    await app.init();\n\n    tenantPaymentService = module.get<TenantPaymentService>(TenantPaymentService);\n    landlordPayoutService = module.get<LandlordPayoutService>(LandlordPayoutService);\n    schedulerService = module.get<SchedulerService>(SchedulerService);\n\n    // Create test users, property, and unit\n    await setupTestData();\n  });\n\n  afterAll(async () => {\n    await cleanupTestData();\n    await app.close();\n    await pool.end();\n  });\n\n  beforeEach(async () => {\n    // Clean up contracts and related data before each test\n    await db.delete(paymentNotifications);\n    await db.delete(landlordEscrowBalances);\n    await db.delete(tenantRentContracts);\n  });\n\n  async function setupTestData() {\n    // Create test landlord\n    const [landlord] = await db.insert(users).values({\n      firstName: 'Test',\n      lastName: 'Landlord',\n      email: 'test.landlord@integration.com',\n      password: 'hashedpassword',\n      phoneNumber: '+1234567890',\n      role: 'landlord',\n    }).returning();\n\n    // Create test tenant\n    const [tenant] = await db.insert(users).values({\n      firstName: 'Test',\n      lastName: 'Tenant',\n      email: 'test.tenant@integration.com',\n      password: 'hashedpassword',\n      phoneNumber: '+1234567891',\n      role: 'tenant',\n    }).returning();\n\n    // Create test property\n    const [property] = await db.insert(properties).values({\n      landlordId: landlord.id,\n      name: 'Integration Test Property',\n      address: '123 Integration St',\n      city: 'Test City',\n      state: 'Test State',\n      country: 'Test Country',\n      propertyType: 'apartment',\n    }).returning();\n\n    // Create test unit\n    const [unit] = await db.insert(units).values({\n      propertyId: property.id,\n      unitNumber: '101',\n      bedrooms: 2,\n      bathrooms: '1.5',\n      rent: '2500.00',\n    }).returning();\n\n    testLandlord = landlord;\n    testTenant = tenant;\n    testProperty = property;\n    testUnit = unit;\n  }\n\n  async function cleanupTestData() {\n    try {\n      await db.delete(paymentNotifications);\n      await db.delete(landlordEscrowBalances);\n      await db.delete(tenantRentContracts);\n      await db.delete(units).where(eq(units.id, testUnit?.id));\n      await db.delete(properties).where(eq(properties.id, testProperty?.id));\n      await db.delete(users).where(eq(users.id, testLandlord?.id));\n      await db.delete(users).where(eq(users.id, testTenant?.id));\n    } catch (error) {\n      console.error('Error cleaning up test data:', error);\n    }\n  }\n\n  describe('Contract Creation Flow', () => {\n    it('should create a new tenant contract with monthly payout', async () => {\n      const contractData = {\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      };\n\n      const contract = await tenantPaymentService.createRentContract(contractData);\n\n      expect(contract).toBeDefined();\n      expect(contract.id).toBeDefined();\n      expect(contract.tenantId).toBe(testTenant.id);\n      expect(contract.landlordId).toBe(testLandlord.id);\n      expect(contract.landlordPayoutType).toBe(LandlordPayoutType.MONTHLY);\n      expect(contract.status).toBe('active');\n      expect(contract.nextPaymentDue).toBeDefined();\n      expect(contract.transitionStartDate).toBeDefined();\n\n      // Verify transition start date is 3 months before expiry for monthly payout\n      const expiryDate = new Date('2025-12-31T23:59:59.000Z');\n      const expectedTransitionStart = new Date(expiryDate);\n      expectedTransitionStart.setMonth(expectedTransitionStart.getMonth() - 3);\n      \n      expect(contract.transitionStartDate.getMonth()).toBe(expectedTransitionStart.getMonth());\n    });\n\n    it('should create a new tenant contract with yearly payout', async () => {\n      const contractData = {\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.YEARLY,\n        isExistingTenant: false,\n      };\n\n      const contract = await tenantPaymentService.createRentContract(contractData);\n\n      expect(contract.landlordPayoutType).toBe(LandlordPayoutType.YEARLY);\n\n      // Verify transition start date is 6 months before expiry for yearly payout\n      const expiryDate = new Date('2025-12-31T23:59:59.000Z');\n      const expectedTransitionStart = new Date(expiryDate);\n      expectedTransitionStart.setMonth(expectedTransitionStart.getMonth() - 6);\n      \n      expect(contract.transitionStartDate.getMonth()).toBe(expectedTransitionStart.getMonth());\n    });\n\n    it('should create existing tenant contract with original expiry date', async () => {\n      const contractData = {\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: true,\n        originalExpiryDate: new Date('2025-06-30T23:59:59.000Z'),\n      };\n\n      const contract = await tenantPaymentService.createRentContract(contractData);\n\n      expect(contract.isExistingTenant).toBe(true);\n      expect(contract.originalExpiryDate).toBeDefined();\n      expect(new Date(contract.originalExpiryDate!).getTime()).toBe(\n        new Date('2025-06-30T23:59:59.000Z').getTime()\n      );\n    });\n\n    it('should prevent duplicate active contracts for same tenant', async () => {\n      const contractData = {\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      };\n\n      // Create first contract\n      await tenantPaymentService.createRentContract(contractData);\n\n      // Attempt to create second contract for same tenant\n      await expect(\n        tenantPaymentService.createRentContract(contractData)\n      ).rejects.toThrow('Tenant already has an active rent contract');\n    });\n  });\n\n  describe('Payment Processing Flow', () => {\n    let monthlyContract: any;\n    let yearlyContract: any;\n\n    beforeEach(async () => {\n      // Create contracts for testing\n      monthlyContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      });\n\n      // Create a second tenant for yearly contract\n      const [yearlyTenant] = await db.insert(users).values({\n        firstName: 'Yearly',\n        lastName: 'Tenant',\n        email: 'yearly.tenant@integration.com',\n        password: 'hashedpassword',\n        phoneNumber: '+1234567892',\n        role: 'tenant',\n      }).returning();\n\n      yearlyContract = await tenantPaymentService.createRentContract({\n        tenantId: yearlyTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.YEARLY,\n        isExistingTenant: false,\n      });\n    });\n\n    it('should process monthly payment with immediate payout', async () => {\n      const paymentResult = await tenantPaymentService.processMonthlyPayment(\n        monthlyContract.id,\n        2500,\n        'card',\n        'test-ref-123'\n      );\n\n      expect(paymentResult.success).toBe(true);\n      expect(paymentResult.payoutType).toBe(LandlordPayoutType.MONTHLY);\n      expect(paymentResult.message).toContain('immediately');\n\n      // Verify next payment due was updated\n      const updatedContract = await tenantPaymentService.getContractById(monthlyContract.id);\n      const originalDue = new Date(monthlyContract.nextPaymentDue);\n      const newDue = new Date(updatedContract.nextPaymentDue);\n      \n      expect(newDue.getMonth()).toBe((originalDue.getMonth() + 1) % 12);\n    });\n\n    it('should process monthly payment with escrow accumulation', async () => {\n      const paymentResult = await tenantPaymentService.processMonthlyPayment(\n        yearlyContract.id,\n        2500,\n        'card',\n        'test-ref-456'\n      );\n\n      expect(paymentResult.success).toBe(true);\n      expect(paymentResult.payoutType).toBe(LandlordPayoutType.YEARLY);\n      expect(paymentResult.message).toContain('escrow');\n\n      // Verify escrow balance was created\n      const escrowBalances = await landlordPayoutService.getLandlordEscrowBalances(testLandlord.id);\n      expect(escrowBalances).toHaveLength(1);\n      expect(parseFloat(escrowBalances[0].totalEscrowed)).toBe(2500);\n      expect(escrowBalances[0].monthsAccumulated).toBe(1);\n    });\n\n    it('should accumulate multiple payments in escrow', async () => {\n      // First payment\n      await tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500);\n      \n      // Second payment\n      await tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500);\n\n      // Verify escrow accumulation\n      const escrowBalances = await landlordPayoutService.getLandlordEscrowBalances(testLandlord.id);\n      expect(escrowBalances).toHaveLength(1);\n      expect(parseFloat(escrowBalances[0].totalEscrowed)).toBe(5000);\n      expect(escrowBalances[0].monthsAccumulated).toBe(2);\n    });\n\n    it('should reject payment with incorrect amount', async () => {\n      await expect(\n        tenantPaymentService.processMonthlyPayment(monthlyContract.id, 2000) // Wrong amount\n      ).rejects.toThrow('Payment amount 2000 does not match expected monthly amount 2500');\n    });\n\n    it('should reject payment that is too early', async () => {\n      // Set next payment due to far future\n      await db.update(tenantRentContracts)\n        .set({ nextPaymentDue: new Date('2025-12-01T00:00:00.000Z') })\n        .where(eq(tenantRentContracts.id, monthlyContract.id));\n\n      await expect(\n        tenantPaymentService.processMonthlyPayment(monthlyContract.id, 2500)\n      ).rejects.toThrow('Payment is too early');\n    });\n  });\n\n  describe('Escrow Release Flow', () => {\n    let yearlyContract: any;\n    let escrowBalance: any;\n\n    beforeEach(async () => {\n      // Create yearly contract\n      yearlyContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-01-31T23:59:59.000Z'), // Near future for testing\n        landlordPayoutType: LandlordPayoutType.YEARLY,\n        isExistingTenant: false,\n      });\n\n      // Add some payments to escrow\n      await tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500);\n      await tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500);\n      await tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500);\n\n      const escrowBalances = await landlordPayoutService.getLandlordEscrowBalances(testLandlord.id);\n      escrowBalance = escrowBalances[0];\n    });\n\n    it('should release escrow balance when contract expires', async () => {\n      // Set escrow to be ready for release (past expected release date)\n      await db.update(landlordEscrowBalances)\n        .set({ expectedReleaseDate: new Date('2024-01-01T00:00:00.000Z') }) // Past date\n        .where(eq(landlordEscrowBalances.id, escrowBalance.id));\n\n      const releaseResults = await landlordPayoutService.checkEscrowReleases();\n\n      expect(releaseResults).toHaveLength(1);\n      expect(releaseResults[0].success).toBe(true);\n      expect(releaseResults[0].releasedAmount).toBe(7500); // 3 payments of 2500\n      expect(releaseResults[0].landlordId).toBe(testLandlord.id);\n\n      // Verify escrow is marked as released\n      const [updatedEscrow] = await db.select()\n        .from(landlordEscrowBalances)\n        .where(eq(landlordEscrowBalances.id, escrowBalance.id));\n\n      expect(updatedEscrow.isReleased).toBe(true);\n      expect(updatedEscrow.releasedAt).toBeDefined();\n      expect(parseFloat(updatedEscrow.releasedAmount!)).toBe(7500);\n    });\n\n    it('should force release escrow for early termination', async () => {\n      const releaseResult = await landlordPayoutService.forceReleaseEscrow(\n        yearlyContract.id,\n        'Early contract termination'\n      );\n\n      expect(releaseResult.success).toBe(true);\n      expect(releaseResult.releasedAmount).toBe(7500);\n      expect(releaseResult.landlordId).toBe(testLandlord.id);\n    });\n\n    it('should calculate total escrowed amount correctly', async () => {\n      const totalEscrowed = await landlordPayoutService.getTotalEscrowedAmount(testLandlord.id);\n      expect(totalEscrowed).toBe(7500);\n\n      // After release, total should be 0\n      await landlordPayoutService.forceReleaseEscrow(yearlyContract.id);\n      const totalAfterRelease = await landlordPayoutService.getTotalEscrowedAmount(testLandlord.id);\n      expect(totalAfterRelease).toBe(0);\n    });\n  });\n\n  describe('Contract Status Management', () => {\n    let testContract: any;\n\n    beforeEach(async () => {\n      testContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      });\n    });\n\n    it('should update contract status', async () => {\n      const updatedContract = await tenantPaymentService.updateContractStatus(\n        testContract.id,\n        ContractStatus.TERMINATED\n      );\n\n      expect(updatedContract.status).toBe('terminated');\n      expect(updatedContract.updatedAt).toBeDefined();\n    });\n\n    it('should mark contract as expired when payment would exceed expiry', async () => {\n      // Create contract that expires soon\n      const shortContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2024-12-15T23:59:59.000Z'), // Expires soon\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      });\n\n      // Set next payment due close to expiry\n      await db.update(tenantRentContracts)\n        .set({ nextPaymentDue: new Date('2024-12-01T00:00:00.000Z') })\n        .where(eq(tenantRentContracts.id, shortContract.id));\n\n      // Update next payment due - should mark as expired\n      await tenantPaymentService.updateNextPaymentDue(shortContract.id);\n\n      const updatedContract = await tenantPaymentService.getContractById(shortContract.id);\n      expect(updatedContract.status).toBe('expired');\n    });\n\n    it('should get contracts with due payments', async () => {\n      // Set payment due to today\n      const today = new Date();\n      await db.update(tenantRentContracts)\n        .set({ nextPaymentDue: today })\n        .where(eq(tenantRentContracts.id, testContract.id));\n\n      const dueContracts = await tenantPaymentService.getContractsWithDuePayments(today);\n      expect(dueContracts).toHaveLength(1);\n      expect(dueContracts[0].id).toBe(testContract.id);\n    });\n\n    it('should get expiring contracts', async () => {\n      // Create contract expiring soon\n      const expiringContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000), // 5 days from now\n        landlordPayoutType: LandlordPayoutType.YEARLY,\n        isExistingTenant: false,\n      });\n\n      const expiringContracts = await tenantPaymentService.getExpiringContracts(7);\n      expect(expiringContracts).toHaveLength(1);\n      expect(expiringContracts[0].id).toBe(expiringContract.id);\n    });\n  });\n\n  describe('Scheduler Service Integration', () => {\n    let testContract: any;\n\n    beforeEach(async () => {\n      testContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      });\n    });\n\n    it('should check due payments without errors', async () => {\n      // Set payment as due\n      const today = new Date();\n      await db.update(tenantRentContracts)\n        .set({ nextPaymentDue: today })\n        .where(eq(tenantRentContracts.id, testContract.id));\n\n      // Should not throw error\n      await expect(schedulerService.checkDuePayments()).resolves.not.toThrow();\n    });\n\n    it('should send payment reminders without errors', async () => {\n      // Set payment as due\n      const today = new Date();\n      await db.update(tenantRentContracts)\n        .set({ nextPaymentDue: today })\n        .where(eq(tenantRentContracts.id, testContract.id));\n\n      // Should not throw error\n      await expect(schedulerService.sendPaymentReminders()).resolves.not.toThrow();\n    });\n\n    it('should process escrow releases without errors', async () => {\n      // Should not throw error even with no escrow to release\n      await expect(schedulerService.processEscrowReleases()).resolves.not.toThrow();\n    });\n\n    it('should update overdue payment statuses without errors', async () => {\n      // Set payment as overdue\n      const pastDate = new Date(Date.now() - 5 * 24 * 60 * 60 * 1000); // 5 days ago\n      await db.update(tenantRentContracts)\n        .set({ nextPaymentDue: pastDate })\n        .where(eq(tenantRentContracts.id, testContract.id));\n\n      // Should not throw error\n      await expect(schedulerService.updateOverduePaymentStatuses()).resolves.not.toThrow();\n    });\n\n    it('should get payment due summary', async () => {\n      // Set payment as due\n      const today = new Date();\n      await db.update(tenantRentContracts)\n        .set({ nextPaymentDue: today })\n        .where(eq(tenantRentContracts.id, testContract.id));\n\n      const summary = await schedulerService.getPaymentDueSummary();\n\n      expect(summary).toBeDefined();\n      expect(summary.totalDue).toBe(2500);\n      expect(summary.contractsWithDuePayments).toBe(1);\n      expect(summary.totalOverdue).toBe(0);\n      expect(summary.contractsWithOverduePayments).toBe(0);\n    });\n\n    it('should get scheduler health status', async () => {\n      const health = await schedulerService.getSchedulerHealth();\n\n      expect(health).toBeDefined();\n      expect(health.status).toBeDefined();\n      expect(health.metrics).toBeDefined();\n      expect(health.metrics.totalContracts).toBeGreaterThanOrEqual(1);\n      expect(health.metrics.activeContracts).toBeGreaterThanOrEqual(1);\n    });\n  });\n\n  describe('Query and Filtering', () => {\n    let contract1: any;\n    let contract2: any;\n    let secondLandlord: any;\n\n    beforeEach(async () => {\n      // Create second landlord\n      const [landlord2] = await db.insert(users).values({\n        firstName: 'Second',\n        lastName: 'Landlord',\n        email: 'second.landlord@integration.com',\n        password: 'hashedpassword',\n        phoneNumber: '+1234567893',\n        role: 'landlord',\n      }).returning();\n      secondLandlord = landlord2;\n\n      // Create contracts for different landlords\n      contract1 = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      });\n\n      // Create second property for second landlord\n      const [property2] = await db.insert(properties).values({\n        landlordId: secondLandlord.id,\n        name: 'Second Property',\n        address: '456 Second St',\n        city: 'Test City',\n        state: 'Test State',\n        country: 'Test Country',\n        propertyType: 'house',\n      }).returning();\n\n      const [unit2] = await db.insert(units).values({\n        propertyId: property2.id,\n        unitNumber: '201',\n        bedrooms: 3,\n        bathrooms: '2',\n        rent: '3000.00',\n      }).returning();\n\n      // Create second tenant\n      const [tenant2] = await db.insert(users).values({\n        firstName: 'Second',\n        lastName: 'Tenant',\n        email: 'second.tenant@integration.com',\n        password: 'hashedpassword',\n        phoneNumber: '+1234567894',\n        role: 'tenant',\n      }).returning();\n\n      contract2 = await tenantPaymentService.createRentContract({\n        tenantId: tenant2.id,\n        landlordId: secondLandlord.id,\n        propertyId: property2.id,\n        unitId: unit2.id,\n        monthlyAmount: 3000,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.YEARLY,\n        isExistingTenant: false,\n      });\n    });\n\n    it('should filter contracts by landlord', async () => {\n      const landlord1Contracts = await tenantPaymentService.getActiveContracts(undefined, testLandlord.id);\n      const landlord2Contracts = await tenantPaymentService.getActiveContracts(undefined, secondLandlord.id);\n\n      expect(landlord1Contracts).toHaveLength(1);\n      expect(landlord1Contracts[0].id).toBe(contract1.id);\n\n      expect(landlord2Contracts).toHaveLength(1);\n      expect(landlord2Contracts[0].id).toBe(contract2.id);\n    });\n\n    it('should filter contracts by tenant', async () => {\n      const tenant1Contracts = await tenantPaymentService.getActiveContracts(testTenant.id);\n      expect(tenant1Contracts).toHaveLength(1);\n      expect(tenant1Contracts[0].id).toBe(contract1.id);\n    });\n\n    it('should get all contracts without filter', async () => {\n      const allContracts = await tenantPaymentService.getActiveContracts();\n      expect(allContracts.length).toBeGreaterThanOrEqual(2);\n    });\n\n    it('should filter contracts by property', async () => {\n      const propertyContracts = await tenantPaymentService.getActiveContractsWithQuery({\n        propertyId: testProperty.id\n      });\n\n      expect(propertyContracts).toHaveLength(1);\n      expect(propertyContracts[0].id).toBe(contract1.id);\n    });\n\n    it('should get all contracts including inactive ones', async () => {\n      // Terminate one contract\n      await tenantPaymentService.updateContractStatus(contract1.id, ContractStatus.TERMINATED);\n\n      const allContracts = await tenantPaymentService.getAllContracts();\n      const activeContracts = await tenantPaymentService.getActiveContracts();\n\n      expect(allContracts.length).toBeGreaterThanOrEqual(2);\n      expect(activeContracts).toHaveLength(1); // Only contract2 should be active\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle non-existent contract gracefully', async () => {\n      await expect(\n        tenantPaymentService.getContractById('00000000-0000-0000-0000-000000000000')\n      ).rejects.toThrow('Rent contract not found');\n    });\n\n    it('should handle payment processing for non-existent contract', async () => {\n      await expect(\n        tenantPaymentService.processMonthlyPayment('00000000-0000-0000-0000-000000000000', 2500)\n      ).rejects.toThrow('Rent contract not found');\n    });\n\n    it('should handle escrow release for non-existent escrow', async () => {\n      await expect(\n        landlordPayoutService.releaseEscrowBalance('00000000-0000-0000-0000-000000000000')\n      ).rejects.toThrow('Escrow balance not found or already released');\n    });\n\n    it('should handle force release for contract with no escrow', async () => {\n      const monthlyContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      });\n\n      await expect(\n        landlordPayoutService.forceReleaseEscrow(monthlyContract.id)\n      ).rejects.toThrow('No active escrow found for contract');\n    });\n\n    it('should validate contract creation with past expiry date', async () => {\n      const invalidContractData = {\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2020-12-31T23:59:59.000Z'), // Past date\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      };\n\n      await expect(\n        tenantPaymentService.createRentContract(invalidContractData)\n      ).rejects.toThrow('Contract expiry date must be in the future');\n    });\n\n    it('should validate existing tenant without original expiry date', async () => {\n      const invalidContractData = {\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: true,\n        // Missing originalExpiryDate\n      };\n\n      await expect(\n        tenantPaymentService.createRentContract(invalidContractData)\n      ).rejects.toThrow('Original expiry date is required for existing tenants');\n    });\n\n    it('should handle zero or negative monthly amount', async () => {\n      const invalidContractData = {\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 0,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.MONTHLY,\n        isExistingTenant: false,\n      };\n\n      await expect(\n        tenantPaymentService.createRentContract(invalidContractData)\n      ).rejects.toThrow('Monthly amount must be greater than 0');\n    });\n  });\n\n  describe('Performance and Concurrency', () => {\n    it('should handle multiple concurrent contract creations', async () => {\n      // Create multiple tenants\n      const tenants = await Promise.all([\n        db.insert(users).values({\n          firstName: 'Concurrent',\n          lastName: 'Tenant1',\n          email: 'concurrent1@integration.com',\n          password: 'hashedpassword',\n          phoneNumber: '+1234567895',\n          role: 'tenant',\n        }).returning(),\n        db.insert(users).values({\n          firstName: 'Concurrent',\n          lastName: 'Tenant2',\n          email: 'concurrent2@integration.com',\n          password: 'hashedpassword',\n          phoneNumber: '+1234567896',\n          role: 'tenant',\n        }).returning(),\n        db.insert(users).values({\n          firstName: 'Concurrent',\n          lastName: 'Tenant3',\n          email: 'concurrent3@integration.com',\n          password: 'hashedpassword',\n          phoneNumber: '+1234567897',\n          role: 'tenant',\n        }).returning(),\n      ]);\n\n      // Create contracts concurrently\n      const contractPromises = tenants.map(([tenant]) =>\n        tenantPaymentService.createRentContract({\n          tenantId: tenant.id,\n          landlordId: testLandlord.id,\n          propertyId: testProperty.id,\n          unitId: testUnit.id,\n          monthlyAmount: 2500,\n          expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n          landlordPayoutType: LandlordPayoutType.MONTHLY,\n          isExistingTenant: false,\n        })\n      );\n\n      const contracts = await Promise.all(contractPromises);\n\n      expect(contracts).toHaveLength(3);\n      contracts.forEach(contract => {\n        expect(contract.id).toBeDefined();\n        expect(contract.status).toBe('active');\n      });\n    });\n\n    it('should handle concurrent payments to same escrow', async () => {\n      const yearlyContract = await tenantPaymentService.createRentContract({\n        tenantId: testTenant.id,\n        landlordId: testLandlord.id,\n        propertyId: testProperty.id,\n        unitId: testUnit.id,\n        monthlyAmount: 2500,\n        expiryDate: new Date('2025-12-31T23:59:59.000Z'),\n        landlordPayoutType: LandlordPayoutType.YEARLY,\n        isExistingTenant: false,\n      });\n\n      // Process multiple payments concurrently\n      const paymentPromises = [\n        tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500),\n        tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500),\n        tenantPaymentService.processMonthlyPayment(yearlyContract.id, 2500),\n      ];\n\n      const results = await Promise.all(paymentPromises);\n\n      expect(results).toHaveLength(3);\n      results.forEach(result => {\n        expect(result.success).toBe(true);\n        expect(result.payoutType).toBe(LandlordPayoutType.YEARLY);\n      });\n\n      // Verify final escrow balance\n      const escrowBalances = await landlordPayoutService.getLandlordEscrowBalances(testLandlord.id);\n      expect(escrowBalances).toHaveLength(1);\n      expect(parseFloat(escrowBalances[0].totalEscrowed)).toBe(7500);\n      expect(escrowBalances[0].monthsAccumulated).toBe(3);\n    });\n  });\n});"],"names":["describe","app","module","tenantPaymentService","landlordPayoutService","schedulerService","db","pool","testLandlord","testTenant","testProperty","testUnit","beforeAll","Pool","connectionString","process","env","DATABASE_URL","drizzle","Test","createTestingModule","imports","ConfigModule","forRoot","isGlobal","ScheduleModule","DatabaseModule","EmailModule","TenantRentContractsModule","compile","createNestApplication","init","get","TenantPaymentService","LandlordPayoutService","SchedulerService","setupTestData","afterAll","cleanupTestData","close","end","beforeEach","delete","paymentNotifications","landlordEscrowBalances","tenantRentContracts","landlord","insert","users","values","firstName","lastName","email","password","phoneNumber","role","returning","tenant","property","properties","landlordId","id","name","address","city","state","country","propertyType","unit","units","propertyId","unitNumber","bedrooms","bathrooms","rent","where","eq","error","console","it","contractData","tenantId","unitId","monthlyAmount","expiryDate","Date","landlordPayoutType","LandlordPayoutType","MONTHLY","isExistingTenant","contract","createRentContract","expect","toBeDefined","toBe","status","nextPaymentDue","transitionStartDate","expectedTransitionStart","setMonth","getMonth","YEARLY","originalExpiryDate","getTime","rejects","toThrow","monthlyContract","yearlyContract","yearlyTenant","paymentResult","processMonthlyPayment","success","payoutType","message","toContain","updatedContract","getContractById","originalDue","newDue","escrowBalances","getLandlordEscrowBalances","toHaveLength","parseFloat","totalEscrowed","monthsAccumulated","update","set","escrowBalance","expectedReleaseDate","releaseResults","checkEscrowReleases","releasedAmount","updatedEscrow","select","from","isReleased","releasedAt","releaseResult","forceReleaseEscrow","getTotalEscrowedAmount","totalAfterRelease","testContract","updateContractStatus","ContractStatus","TERMINATED","updatedAt","shortContract","updateNextPaymentDue","today","dueContracts","getContractsWithDuePayments","expiringContract","now","expiringContracts","getExpiringContracts","checkDuePayments","resolves","not","sendPaymentReminders","processEscrowReleases","pastDate","updateOverduePaymentStatuses","summary","getPaymentDueSummary","totalDue","contractsWithDuePayments","totalOverdue","contractsWithOverduePayments","health","getSchedulerHealth","metrics","totalContracts","toBeGreaterThanOrEqual","activeContracts","contract1","contract2","secondLandlord","landlord2","property2","unit2","tenant2","landlord1Contracts","getActiveContracts","undefined","landlord2Contracts","tenant1Contracts","allContracts","length","propertyContracts","getActiveContractsWithQuery","getAllContracts","releaseEscrowBalance","invalidContractData","tenants","Promise","all","contractPromises","map","contracts","forEach","paymentPromises","results","result"],"mappings":";;;;yBAAoC;wBAEP;0BACE;8BAEP;oBACH;4BACG;2CAEkB;gCACX;6BACH;sCACS;uCACC;kCACL;wBAU1B;uCAC4C;AAEnDA,SAAS,2CAA2C;IAClD,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IAEJ,IAAIC;IACJ,IAAIC;IAEJ,YAAY;IACZ,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IAEJC,UAAU;QACR,iCAAiC;QACjCL,OAAO,IAAIM,QAAI,CAAC;YACdC,kBAAkBC,QAAQC,GAAG,CAACC,YAAY,IAAI;QAChD;QACAX,KAAKY,IAAAA,qBAAO,EAACX;QAEbL,SAAS,MAAMiB,aAAI,CAACC,mBAAmB,CAAC;YACtCC,SAAS;gBACPC,oBAAY,CAACC,OAAO,CAAC;oBAAEC,UAAU;gBAAK;gBACtCC,wBAAc,CAACF,OAAO;gBACtBG,8BAAc;gBACdC,wBAAW;gBACXC,oDAAyB;aAC1B;QACH,GAAGC,OAAO;QAEV5B,MAAMC,OAAO4B,qBAAqB;QAClC,MAAM7B,IAAI8B,IAAI;QAEd5B,uBAAuBD,OAAO8B,GAAG,CAAuBC,0CAAoB;QAC5E7B,wBAAwBF,OAAO8B,GAAG,CAAwBE,4CAAqB;QAC/E7B,mBAAmBH,OAAO8B,GAAG,CAAmBG,kCAAgB;QAEhE,wCAAwC;QACxC,MAAMC;IACR;IAEAC,SAAS;QACP,MAAMC;QACN,MAAMrC,IAAIsC,KAAK;QACf,MAAMhC,KAAKiC,GAAG;IAChB;IAEAC,WAAW;QACT,uDAAuD;QACvD,MAAMnC,GAAGoC,MAAM,CAACC,4BAAoB;QACpC,MAAMrC,GAAGoC,MAAM,CAACE,8BAAsB;QACtC,MAAMtC,GAAGoC,MAAM,CAACG,2BAAmB;IACrC;IAEA,eAAeT;QACb,uBAAuB;QACvB,MAAM,CAACU,SAAS,GAAG,MAAMxC,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;YAC/CC,WAAW;YACXC,UAAU;YACVC,OAAO;YACPC,UAAU;YACVC,aAAa;YACbC,MAAM;QACR,GAAGC,SAAS;QAEZ,qBAAqB;QACrB,MAAM,CAACC,OAAO,GAAG,MAAMnD,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;YAC7CC,WAAW;YACXC,UAAU;YACVC,OAAO;YACPC,UAAU;YACVC,aAAa;YACbC,MAAM;QACR,GAAGC,SAAS;QAEZ,uBAAuB;QACvB,MAAM,CAACE,SAAS,GAAG,MAAMpD,GAAGyC,MAAM,CAACY,kBAAU,EAAEV,MAAM,CAAC;YACpDW,YAAYd,SAASe,EAAE;YACvBC,MAAM;YACNC,SAAS;YACTC,MAAM;YACNC,OAAO;YACPC,SAAS;YACTC,cAAc;QAChB,GAAGX,SAAS;QAEZ,mBAAmB;QACnB,MAAM,CAACY,KAAK,GAAG,MAAM9D,GAAGyC,MAAM,CAACsB,aAAK,EAAEpB,MAAM,CAAC;YAC3CqB,YAAYZ,SAASG,EAAE;YACvBU,YAAY;YACZC,UAAU;YACVC,WAAW;YACXC,MAAM;QACR,GAAGlB,SAAS;QAEZhD,eAAesC;QACfrC,aAAagD;QACb/C,eAAegD;QACf/C,WAAWyD;IACb;IAEA,eAAe9B;QACb,IAAI;YACF,MAAMhC,GAAGoC,MAAM,CAACC,4BAAoB;YACpC,MAAMrC,GAAGoC,MAAM,CAACE,8BAAsB;YACtC,MAAMtC,GAAGoC,MAAM,CAACG,2BAAmB;YACnC,MAAMvC,GAAGoC,MAAM,CAAC2B,aAAK,EAAEM,KAAK,CAACC,IAAAA,cAAE,EAACP,aAAK,CAACR,EAAE,EAAElD,UAAUkD;YACpD,MAAMvD,GAAGoC,MAAM,CAACiB,kBAAU,EAAEgB,KAAK,CAACC,IAAAA,cAAE,EAACjB,kBAAU,CAACE,EAAE,EAAEnD,cAAcmD;YAClE,MAAMvD,GAAGoC,MAAM,CAACM,aAAK,EAAE2B,KAAK,CAACC,IAAAA,cAAE,EAAC5B,aAAK,CAACa,EAAE,EAAErD,cAAcqD;YACxD,MAAMvD,GAAGoC,MAAM,CAACM,aAAK,EAAE2B,KAAK,CAACC,IAAAA,cAAE,EAAC5B,aAAK,CAACa,EAAE,EAAEpD,YAAYoD;QACxD,EAAE,OAAOgB,OAAO;YACdC,QAAQD,KAAK,CAAC,gCAAgCA;QAChD;IACF;IAEA7E,SAAS,0BAA0B;QACjC+E,GAAG,2DAA2D;YAC5D,MAAMC,eAAe;gBACnBC,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,MAAMC,WAAW,MAAMvF,qBAAqBwF,kBAAkB,CAACX;YAE/DY,OAAOF,UAAUG,WAAW;YAC5BD,OAAOF,SAAS7B,EAAE,EAAEgC,WAAW;YAC/BD,OAAOF,SAAST,QAAQ,EAAEa,IAAI,CAACrF,WAAWoD,EAAE;YAC5C+B,OAAOF,SAAS9B,UAAU,EAAEkC,IAAI,CAACtF,aAAaqD,EAAE;YAChD+B,OAAOF,SAASJ,kBAAkB,EAAEQ,IAAI,CAACP,yCAAkB,CAACC,OAAO;YACnEI,OAAOF,SAASK,MAAM,EAAED,IAAI,CAAC;YAC7BF,OAAOF,SAASM,cAAc,EAAEH,WAAW;YAC3CD,OAAOF,SAASO,mBAAmB,EAAEJ,WAAW;YAEhD,4EAA4E;YAC5E,MAAMT,aAAa,IAAIC,KAAK;YAC5B,MAAMa,0BAA0B,IAAIb,KAAKD;YACzCc,wBAAwBC,QAAQ,CAACD,wBAAwBE,QAAQ,KAAK;YAEtER,OAAOF,SAASO,mBAAmB,CAACG,QAAQ,IAAIN,IAAI,CAACI,wBAAwBE,QAAQ;QACvF;QAEArB,GAAG,0DAA0D;YAC3D,MAAMC,eAAe;gBACnBC,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACc,MAAM;gBAC7CZ,kBAAkB;YACpB;YAEA,MAAMC,WAAW,MAAMvF,qBAAqBwF,kBAAkB,CAACX;YAE/DY,OAAOF,SAASJ,kBAAkB,EAAEQ,IAAI,CAACP,yCAAkB,CAACc,MAAM;YAElE,2EAA2E;YAC3E,MAAMjB,aAAa,IAAIC,KAAK;YAC5B,MAAMa,0BAA0B,IAAIb,KAAKD;YACzCc,wBAAwBC,QAAQ,CAACD,wBAAwBE,QAAQ,KAAK;YAEtER,OAAOF,SAASO,mBAAmB,CAACG,QAAQ,IAAIN,IAAI,CAACI,wBAAwBE,QAAQ;QACvF;QAEArB,GAAG,oEAAoE;YACrE,MAAMC,eAAe;gBACnBC,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;gBAClBa,oBAAoB,IAAIjB,KAAK;YAC/B;YAEA,MAAMK,WAAW,MAAMvF,qBAAqBwF,kBAAkB,CAACX;YAE/DY,OAAOF,SAASD,gBAAgB,EAAEK,IAAI,CAAC;YACvCF,OAAOF,SAASY,kBAAkB,EAAET,WAAW;YAC/CD,OAAO,IAAIP,KAAKK,SAASY,kBAAkB,EAAGC,OAAO,IAAIT,IAAI,CAC3D,IAAIT,KAAK,4BAA4BkB,OAAO;QAEhD;QAEAxB,GAAG,6DAA6D;YAC9D,MAAMC,eAAe;gBACnBC,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,wBAAwB;YACxB,MAAMtF,qBAAqBwF,kBAAkB,CAACX;YAE9C,oDAAoD;YACpD,MAAMY,OACJzF,qBAAqBwF,kBAAkB,CAACX,eACxCwB,OAAO,CAACC,OAAO,CAAC;QACpB;IACF;IAEAzG,SAAS,2BAA2B;QAClC,IAAI0G;QACJ,IAAIC;QAEJlE,WAAW;YACT,+BAA+B;YAC/BiE,kBAAkB,MAAMvG,qBAAqBwF,kBAAkB,CAAC;gBAC9DV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,6CAA6C;YAC7C,MAAM,CAACmB,aAAa,GAAG,MAAMtG,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;gBACnDC,WAAW;gBACXC,UAAU;gBACVC,OAAO;gBACPC,UAAU;gBACVC,aAAa;gBACbC,MAAM;YACR,GAAGC,SAAS;YAEZmD,iBAAiB,MAAMxG,qBAAqBwF,kBAAkB,CAAC;gBAC7DV,UAAU2B,aAAa/C,EAAE;gBACzBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACc,MAAM;gBAC7CZ,kBAAkB;YACpB;QACF;QAEAV,GAAG,wDAAwD;YACzD,MAAM8B,gBAAgB,MAAM1G,qBAAqB2G,qBAAqB,CACpEJ,gBAAgB7C,EAAE,EAClB,MACA,QACA;YAGF+B,OAAOiB,cAAcE,OAAO,EAAEjB,IAAI,CAAC;YACnCF,OAAOiB,cAAcG,UAAU,EAAElB,IAAI,CAACP,yCAAkB,CAACC,OAAO;YAChEI,OAAOiB,cAAcI,OAAO,EAAEC,SAAS,CAAC;YAExC,sCAAsC;YACtC,MAAMC,kBAAkB,MAAMhH,qBAAqBiH,eAAe,CAACV,gBAAgB7C,EAAE;YACrF,MAAMwD,cAAc,IAAIhC,KAAKqB,gBAAgBV,cAAc;YAC3D,MAAMsB,SAAS,IAAIjC,KAAK8B,gBAAgBnB,cAAc;YAEtDJ,OAAO0B,OAAOlB,QAAQ,IAAIN,IAAI,CAAC,AAACuB,CAAAA,YAAYjB,QAAQ,KAAK,CAAA,IAAK;QAChE;QAEArB,GAAG,2DAA2D;YAC5D,MAAM8B,gBAAgB,MAAM1G,qBAAqB2G,qBAAqB,CACpEH,eAAe9C,EAAE,EACjB,MACA,QACA;YAGF+B,OAAOiB,cAAcE,OAAO,EAAEjB,IAAI,CAAC;YACnCF,OAAOiB,cAAcG,UAAU,EAAElB,IAAI,CAACP,yCAAkB,CAACc,MAAM;YAC/DT,OAAOiB,cAAcI,OAAO,EAAEC,SAAS,CAAC;YAExC,oCAAoC;YACpC,MAAMK,iBAAiB,MAAMnH,sBAAsBoH,yBAAyB,CAAChH,aAAaqD,EAAE;YAC5F+B,OAAO2B,gBAAgBE,YAAY,CAAC;YACpC7B,OAAO8B,WAAWH,cAAc,CAAC,EAAE,CAACI,aAAa,GAAG7B,IAAI,CAAC;YACzDF,OAAO2B,cAAc,CAAC,EAAE,CAACK,iBAAiB,EAAE9B,IAAI,CAAC;QACnD;QAEAf,GAAG,iDAAiD;YAClD,gBAAgB;YAChB,MAAM5E,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;YAEpE,iBAAiB;YACjB,MAAM1D,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;YAEpE,6BAA6B;YAC7B,MAAM0D,iBAAiB,MAAMnH,sBAAsBoH,yBAAyB,CAAChH,aAAaqD,EAAE;YAC5F+B,OAAO2B,gBAAgBE,YAAY,CAAC;YACpC7B,OAAO8B,WAAWH,cAAc,CAAC,EAAE,CAACI,aAAa,GAAG7B,IAAI,CAAC;YACzDF,OAAO2B,cAAc,CAAC,EAAE,CAACK,iBAAiB,EAAE9B,IAAI,CAAC;QACnD;QAEAf,GAAG,+CAA+C;YAChD,MAAMa,OACJzF,qBAAqB2G,qBAAqB,CAACJ,gBAAgB7C,EAAE,EAAE,MAAM,eAAe;cACpF2C,OAAO,CAACC,OAAO,CAAC;QACpB;QAEA1B,GAAG,2CAA2C;YAC5C,qCAAqC;YACrC,MAAMzE,GAAGuH,MAAM,CAAChF,2BAAmB,EAChCiF,GAAG,CAAC;gBAAE9B,gBAAgB,IAAIX,KAAK;YAA4B,GAC3DV,KAAK,CAACC,IAAAA,cAAE,EAAC/B,2BAAmB,CAACgB,EAAE,EAAE6C,gBAAgB7C,EAAE;YAEtD,MAAM+B,OACJzF,qBAAqB2G,qBAAqB,CAACJ,gBAAgB7C,EAAE,EAAE,OAC/D2C,OAAO,CAACC,OAAO,CAAC;QACpB;IACF;IAEAzG,SAAS,uBAAuB;QAC9B,IAAI2G;QACJ,IAAIoB;QAEJtF,WAAW;YACT,yBAAyB;YACzBkE,iBAAiB,MAAMxG,qBAAqBwF,kBAAkB,CAAC;gBAC7DV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACc,MAAM;gBAC7CZ,kBAAkB;YACpB;YAEA,8BAA8B;YAC9B,MAAMtF,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;YACpE,MAAM1D,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;YACpE,MAAM1D,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;YAEpE,MAAM0D,iBAAiB,MAAMnH,sBAAsBoH,yBAAyB,CAAChH,aAAaqD,EAAE;YAC5FkE,gBAAgBR,cAAc,CAAC,EAAE;QACnC;QAEAxC,GAAG,uDAAuD;YACxD,kEAAkE;YAClE,MAAMzE,GAAGuH,MAAM,CAACjF,8BAAsB,EACnCkF,GAAG,CAAC;gBAAEE,qBAAqB,IAAI3C,KAAK;YAA4B,GAAG,YAAY;aAC/EV,KAAK,CAACC,IAAAA,cAAE,EAAChC,8BAAsB,CAACiB,EAAE,EAAEkE,cAAclE,EAAE;YAEvD,MAAMoE,iBAAiB,MAAM7H,sBAAsB8H,mBAAmB;YAEtEtC,OAAOqC,gBAAgBR,YAAY,CAAC;YACpC7B,OAAOqC,cAAc,CAAC,EAAE,CAAClB,OAAO,EAAEjB,IAAI,CAAC;YACvCF,OAAOqC,cAAc,CAAC,EAAE,CAACE,cAAc,EAAErC,IAAI,CAAC,OAAO,qBAAqB;YAC1EF,OAAOqC,cAAc,CAAC,EAAE,CAACrE,UAAU,EAAEkC,IAAI,CAACtF,aAAaqD,EAAE;YAEzD,sCAAsC;YACtC,MAAM,CAACuE,cAAc,GAAG,MAAM9H,GAAG+H,MAAM,GACpCC,IAAI,CAAC1F,8BAAsB,EAC3B+B,KAAK,CAACC,IAAAA,cAAE,EAAChC,8BAAsB,CAACiB,EAAE,EAAEkE,cAAclE,EAAE;YAEvD+B,OAAOwC,cAAcG,UAAU,EAAEzC,IAAI,CAAC;YACtCF,OAAOwC,cAAcI,UAAU,EAAE3C,WAAW;YAC5CD,OAAO8B,WAAWU,cAAcD,cAAc,GAAIrC,IAAI,CAAC;QACzD;QAEAf,GAAG,qDAAqD;YACtD,MAAM0D,gBAAgB,MAAMrI,sBAAsBsI,kBAAkB,CAClE/B,eAAe9C,EAAE,EACjB;YAGF+B,OAAO6C,cAAc1B,OAAO,EAAEjB,IAAI,CAAC;YACnCF,OAAO6C,cAAcN,cAAc,EAAErC,IAAI,CAAC;YAC1CF,OAAO6C,cAAc7E,UAAU,EAAEkC,IAAI,CAACtF,aAAaqD,EAAE;QACvD;QAEAkB,GAAG,oDAAoD;YACrD,MAAM4C,gBAAgB,MAAMvH,sBAAsBuI,sBAAsB,CAACnI,aAAaqD,EAAE;YACxF+B,OAAO+B,eAAe7B,IAAI,CAAC;YAE3B,mCAAmC;YACnC,MAAM1F,sBAAsBsI,kBAAkB,CAAC/B,eAAe9C,EAAE;YAChE,MAAM+E,oBAAoB,MAAMxI,sBAAsBuI,sBAAsB,CAACnI,aAAaqD,EAAE;YAC5F+B,OAAOgD,mBAAmB9C,IAAI,CAAC;QACjC;IACF;IAEA9F,SAAS,8BAA8B;QACrC,IAAI6I;QAEJpG,WAAW;YACToG,eAAe,MAAM1I,qBAAqBwF,kBAAkB,CAAC;gBAC3DV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;QACF;QAEAV,GAAG,iCAAiC;YAClC,MAAMoC,kBAAkB,MAAMhH,qBAAqB2I,oBAAoB,CACrED,aAAahF,EAAE,EACfkF,qCAAc,CAACC,UAAU;YAG3BpD,OAAOuB,gBAAgBpB,MAAM,EAAED,IAAI,CAAC;YACpCF,OAAOuB,gBAAgB8B,SAAS,EAAEpD,WAAW;QAC/C;QAEAd,GAAG,oEAAoE;YACrE,oCAAoC;YACpC,MAAMmE,gBAAgB,MAAM/I,qBAAqBwF,kBAAkB,CAAC;gBAClEV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,uCAAuC;YACvC,MAAMnF,GAAGuH,MAAM,CAAChF,2BAAmB,EAChCiF,GAAG,CAAC;gBAAE9B,gBAAgB,IAAIX,KAAK;YAA4B,GAC3DV,KAAK,CAACC,IAAAA,cAAE,EAAC/B,2BAAmB,CAACgB,EAAE,EAAEqF,cAAcrF,EAAE;YAEpD,mDAAmD;YACnD,MAAM1D,qBAAqBgJ,oBAAoB,CAACD,cAAcrF,EAAE;YAEhE,MAAMsD,kBAAkB,MAAMhH,qBAAqBiH,eAAe,CAAC8B,cAAcrF,EAAE;YACnF+B,OAAOuB,gBAAgBpB,MAAM,EAAED,IAAI,CAAC;QACtC;QAEAf,GAAG,0CAA0C;YAC3C,2BAA2B;YAC3B,MAAMqE,QAAQ,IAAI/D;YAClB,MAAM/E,GAAGuH,MAAM,CAAChF,2BAAmB,EAChCiF,GAAG,CAAC;gBAAE9B,gBAAgBoD;YAAM,GAC5BzE,KAAK,CAACC,IAAAA,cAAE,EAAC/B,2BAAmB,CAACgB,EAAE,EAAEgF,aAAahF,EAAE;YAEnD,MAAMwF,eAAe,MAAMlJ,qBAAqBmJ,2BAA2B,CAACF;YAC5ExD,OAAOyD,cAAc5B,YAAY,CAAC;YAClC7B,OAAOyD,YAAY,CAAC,EAAE,CAACxF,EAAE,EAAEiC,IAAI,CAAC+C,aAAahF,EAAE;QACjD;QAEAkB,GAAG,iCAAiC;YAClC,gCAAgC;YAChC,MAAMwE,mBAAmB,MAAMpJ,qBAAqBwF,kBAAkB,CAAC;gBACrEV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAKA,KAAKmE,GAAG,KAAK,IAAI,KAAK,KAAK,KAAK;gBACrDlE,oBAAoBC,yCAAkB,CAACc,MAAM;gBAC7CZ,kBAAkB;YACpB;YAEA,MAAMgE,oBAAoB,MAAMtJ,qBAAqBuJ,oBAAoB,CAAC;YAC1E9D,OAAO6D,mBAAmBhC,YAAY,CAAC;YACvC7B,OAAO6D,iBAAiB,CAAC,EAAE,CAAC5F,EAAE,EAAEiC,IAAI,CAACyD,iBAAiB1F,EAAE;QAC1D;IACF;IAEA7D,SAAS,iCAAiC;QACxC,IAAI6I;QAEJpG,WAAW;YACToG,eAAe,MAAM1I,qBAAqBwF,kBAAkB,CAAC;gBAC3DV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;QACF;QAEAV,GAAG,4CAA4C;YAC7C,qBAAqB;YACrB,MAAMqE,QAAQ,IAAI/D;YAClB,MAAM/E,GAAGuH,MAAM,CAAChF,2BAAmB,EAChCiF,GAAG,CAAC;gBAAE9B,gBAAgBoD;YAAM,GAC5BzE,KAAK,CAACC,IAAAA,cAAE,EAAC/B,2BAAmB,CAACgB,EAAE,EAAEgF,aAAahF,EAAE;YAEnD,yBAAyB;YACzB,MAAM+B,OAAOvF,iBAAiBsJ,gBAAgB,IAAIC,QAAQ,CAACC,GAAG,CAACpD,OAAO;QACxE;QAEA1B,GAAG,gDAAgD;YACjD,qBAAqB;YACrB,MAAMqE,QAAQ,IAAI/D;YAClB,MAAM/E,GAAGuH,MAAM,CAAChF,2BAAmB,EAChCiF,GAAG,CAAC;gBAAE9B,gBAAgBoD;YAAM,GAC5BzE,KAAK,CAACC,IAAAA,cAAE,EAAC/B,2BAAmB,CAACgB,EAAE,EAAEgF,aAAahF,EAAE;YAEnD,yBAAyB;YACzB,MAAM+B,OAAOvF,iBAAiByJ,oBAAoB,IAAIF,QAAQ,CAACC,GAAG,CAACpD,OAAO;QAC5E;QAEA1B,GAAG,iDAAiD;YAClD,wDAAwD;YACxD,MAAMa,OAAOvF,iBAAiB0J,qBAAqB,IAAIH,QAAQ,CAACC,GAAG,CAACpD,OAAO;QAC7E;QAEA1B,GAAG,yDAAyD;YAC1D,yBAAyB;YACzB,MAAMiF,WAAW,IAAI3E,KAAKA,KAAKmE,GAAG,KAAK,IAAI,KAAK,KAAK,KAAK,OAAO,aAAa;YAC9E,MAAMlJ,GAAGuH,MAAM,CAAChF,2BAAmB,EAChCiF,GAAG,CAAC;gBAAE9B,gBAAgBgE;YAAS,GAC/BrF,KAAK,CAACC,IAAAA,cAAE,EAAC/B,2BAAmB,CAACgB,EAAE,EAAEgF,aAAahF,EAAE;YAEnD,yBAAyB;YACzB,MAAM+B,OAAOvF,iBAAiB4J,4BAA4B,IAAIL,QAAQ,CAACC,GAAG,CAACpD,OAAO;QACpF;QAEA1B,GAAG,kCAAkC;YACnC,qBAAqB;YACrB,MAAMqE,QAAQ,IAAI/D;YAClB,MAAM/E,GAAGuH,MAAM,CAAChF,2BAAmB,EAChCiF,GAAG,CAAC;gBAAE9B,gBAAgBoD;YAAM,GAC5BzE,KAAK,CAACC,IAAAA,cAAE,EAAC/B,2BAAmB,CAACgB,EAAE,EAAEgF,aAAahF,EAAE;YAEnD,MAAMqG,UAAU,MAAM7J,iBAAiB8J,oBAAoB;YAE3DvE,OAAOsE,SAASrE,WAAW;YAC3BD,OAAOsE,QAAQE,QAAQ,EAAEtE,IAAI,CAAC;YAC9BF,OAAOsE,QAAQG,wBAAwB,EAAEvE,IAAI,CAAC;YAC9CF,OAAOsE,QAAQI,YAAY,EAAExE,IAAI,CAAC;YAClCF,OAAOsE,QAAQK,4BAA4B,EAAEzE,IAAI,CAAC;QACpD;QAEAf,GAAG,sCAAsC;YACvC,MAAMyF,SAAS,MAAMnK,iBAAiBoK,kBAAkB;YAExD7E,OAAO4E,QAAQ3E,WAAW;YAC1BD,OAAO4E,OAAOzE,MAAM,EAAEF,WAAW;YACjCD,OAAO4E,OAAOE,OAAO,EAAE7E,WAAW;YAClCD,OAAO4E,OAAOE,OAAO,CAACC,cAAc,EAAEC,sBAAsB,CAAC;YAC7DhF,OAAO4E,OAAOE,OAAO,CAACG,eAAe,EAAED,sBAAsB,CAAC;QAChE;IACF;IAEA5K,SAAS,uBAAuB;QAC9B,IAAI8K;QACJ,IAAIC;QACJ,IAAIC;QAEJvI,WAAW;YACT,yBAAyB;YACzB,MAAM,CAACwI,UAAU,GAAG,MAAM3K,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;gBAChDC,WAAW;gBACXC,UAAU;gBACVC,OAAO;gBACPC,UAAU;gBACVC,aAAa;gBACbC,MAAM;YACR,GAAGC,SAAS;YACZwH,iBAAiBC;YAEjB,2CAA2C;YAC3CH,YAAY,MAAM3K,qBAAqBwF,kBAAkB,CAAC;gBACxDV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,6CAA6C;YAC7C,MAAM,CAACyF,UAAU,GAAG,MAAM5K,GAAGyC,MAAM,CAACY,kBAAU,EAAEV,MAAM,CAAC;gBACrDW,YAAYoH,eAAenH,EAAE;gBAC7BC,MAAM;gBACNC,SAAS;gBACTC,MAAM;gBACNC,OAAO;gBACPC,SAAS;gBACTC,cAAc;YAChB,GAAGX,SAAS;YAEZ,MAAM,CAAC2H,MAAM,GAAG,MAAM7K,GAAGyC,MAAM,CAACsB,aAAK,EAAEpB,MAAM,CAAC;gBAC5CqB,YAAY4G,UAAUrH,EAAE;gBACxBU,YAAY;gBACZC,UAAU;gBACVC,WAAW;gBACXC,MAAM;YACR,GAAGlB,SAAS;YAEZ,uBAAuB;YACvB,MAAM,CAAC4H,QAAQ,GAAG,MAAM9K,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;gBAC9CC,WAAW;gBACXC,UAAU;gBACVC,OAAO;gBACPC,UAAU;gBACVC,aAAa;gBACbC,MAAM;YACR,GAAGC,SAAS;YAEZuH,YAAY,MAAM5K,qBAAqBwF,kBAAkB,CAAC;gBACxDV,UAAUmG,QAAQvH,EAAE;gBACpBD,YAAYoH,eAAenH,EAAE;gBAC7BS,YAAY4G,UAAUrH,EAAE;gBACxBqB,QAAQiG,MAAMtH,EAAE;gBAChBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACc,MAAM;gBAC7CZ,kBAAkB;YACpB;QACF;QAEAV,GAAG,uCAAuC;YACxC,MAAMsG,qBAAqB,MAAMlL,qBAAqBmL,kBAAkB,CAACC,WAAW/K,aAAaqD,EAAE;YACnG,MAAM2H,qBAAqB,MAAMrL,qBAAqBmL,kBAAkB,CAACC,WAAWP,eAAenH,EAAE;YAErG+B,OAAOyF,oBAAoB5D,YAAY,CAAC;YACxC7B,OAAOyF,kBAAkB,CAAC,EAAE,CAACxH,EAAE,EAAEiC,IAAI,CAACgF,UAAUjH,EAAE;YAElD+B,OAAO4F,oBAAoB/D,YAAY,CAAC;YACxC7B,OAAO4F,kBAAkB,CAAC,EAAE,CAAC3H,EAAE,EAAEiC,IAAI,CAACiF,UAAUlH,EAAE;QACpD;QAEAkB,GAAG,qCAAqC;YACtC,MAAM0G,mBAAmB,MAAMtL,qBAAqBmL,kBAAkB,CAAC7K,WAAWoD,EAAE;YACpF+B,OAAO6F,kBAAkBhE,YAAY,CAAC;YACtC7B,OAAO6F,gBAAgB,CAAC,EAAE,CAAC5H,EAAE,EAAEiC,IAAI,CAACgF,UAAUjH,EAAE;QAClD;QAEAkB,GAAG,2CAA2C;YAC5C,MAAM2G,eAAe,MAAMvL,qBAAqBmL,kBAAkB;YAClE1F,OAAO8F,aAAaC,MAAM,EAAEf,sBAAsB,CAAC;QACrD;QAEA7F,GAAG,uCAAuC;YACxC,MAAM6G,oBAAoB,MAAMzL,qBAAqB0L,2BAA2B,CAAC;gBAC/EvH,YAAY5D,aAAamD,EAAE;YAC7B;YAEA+B,OAAOgG,mBAAmBnE,YAAY,CAAC;YACvC7B,OAAOgG,iBAAiB,CAAC,EAAE,CAAC/H,EAAE,EAAEiC,IAAI,CAACgF,UAAUjH,EAAE;QACnD;QAEAkB,GAAG,oDAAoD;YACrD,yBAAyB;YACzB,MAAM5E,qBAAqB2I,oBAAoB,CAACgC,UAAUjH,EAAE,EAAEkF,qCAAc,CAACC,UAAU;YAEvF,MAAM0C,eAAe,MAAMvL,qBAAqB2L,eAAe;YAC/D,MAAMjB,kBAAkB,MAAM1K,qBAAqBmL,kBAAkB;YAErE1F,OAAO8F,aAAaC,MAAM,EAAEf,sBAAsB,CAAC;YACnDhF,OAAOiF,iBAAiBpD,YAAY,CAAC,IAAI,kCAAkC;QAC7E;IACF;IAEAzH,SAAS,iCAAiC;QACxC+E,GAAG,kDAAkD;YACnD,MAAMa,OACJzF,qBAAqBiH,eAAe,CAAC,yCACrCZ,OAAO,CAACC,OAAO,CAAC;QACpB;QAEA1B,GAAG,8DAA8D;YAC/D,MAAMa,OACJzF,qBAAqB2G,qBAAqB,CAAC,wCAAwC,OACnFN,OAAO,CAACC,OAAO,CAAC;QACpB;QAEA1B,GAAG,wDAAwD;YACzD,MAAMa,OACJxF,sBAAsB2L,oBAAoB,CAAC,yCAC3CvF,OAAO,CAACC,OAAO,CAAC;QACpB;QAEA1B,GAAG,2DAA2D;YAC5D,MAAM2B,kBAAkB,MAAMvG,qBAAqBwF,kBAAkB,CAAC;gBACpEV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,MAAMG,OACJxF,sBAAsBsI,kBAAkB,CAAChC,gBAAgB7C,EAAE,GAC3D2C,OAAO,CAACC,OAAO,CAAC;QACpB;QAEA1B,GAAG,2DAA2D;YAC5D,MAAMiH,sBAAsB;gBAC1B/G,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,MAAMG,OACJzF,qBAAqBwF,kBAAkB,CAACqG,sBACxCxF,OAAO,CAACC,OAAO,CAAC;QACpB;QAEA1B,GAAG,gEAAgE;YACjE,MAAMiH,sBAAsB;gBAC1B/G,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YAEpB;YAEA,MAAMG,OACJzF,qBAAqBwF,kBAAkB,CAACqG,sBACxCxF,OAAO,CAACC,OAAO,CAAC;QACpB;QAEA1B,GAAG,iDAAiD;YAClD,MAAMiH,sBAAsB;gBAC1B/G,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;gBAC9CC,kBAAkB;YACpB;YAEA,MAAMG,OACJzF,qBAAqBwF,kBAAkB,CAACqG,sBACxCxF,OAAO,CAACC,OAAO,CAAC;QACpB;IACF;IAEAzG,SAAS,+BAA+B;QACtC+E,GAAG,wDAAwD;YACzD,0BAA0B;YAC1B,MAAMkH,UAAU,MAAMC,QAAQC,GAAG,CAAC;gBAChC7L,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;oBACtBC,WAAW;oBACXC,UAAU;oBACVC,OAAO;oBACPC,UAAU;oBACVC,aAAa;oBACbC,MAAM;gBACR,GAAGC,SAAS;gBACZlD,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;oBACtBC,WAAW;oBACXC,UAAU;oBACVC,OAAO;oBACPC,UAAU;oBACVC,aAAa;oBACbC,MAAM;gBACR,GAAGC,SAAS;gBACZlD,GAAGyC,MAAM,CAACC,aAAK,EAAEC,MAAM,CAAC;oBACtBC,WAAW;oBACXC,UAAU;oBACVC,OAAO;oBACPC,UAAU;oBACVC,aAAa;oBACbC,MAAM;gBACR,GAAGC,SAAS;aACb;YAED,gCAAgC;YAChC,MAAM4I,mBAAmBH,QAAQI,GAAG,CAAC,CAAC,CAAC5I,OAAO,GAC5CtD,qBAAqBwF,kBAAkB,CAAC;oBACtCV,UAAUxB,OAAOI,EAAE;oBACnBD,YAAYpD,aAAaqD,EAAE;oBAC3BS,YAAY5D,aAAamD,EAAE;oBAC3BqB,QAAQvE,SAASkD,EAAE;oBACnBsB,eAAe;oBACfC,YAAY,IAAIC,KAAK;oBACrBC,oBAAoBC,yCAAkB,CAACC,OAAO;oBAC9CC,kBAAkB;gBACpB;YAGF,MAAM6G,YAAY,MAAMJ,QAAQC,GAAG,CAACC;YAEpCxG,OAAO0G,WAAW7E,YAAY,CAAC;YAC/B6E,UAAUC,OAAO,CAAC7G,CAAAA;gBAChBE,OAAOF,SAAS7B,EAAE,EAAEgC,WAAW;gBAC/BD,OAAOF,SAASK,MAAM,EAAED,IAAI,CAAC;YAC/B;QACF;QAEAf,GAAG,oDAAoD;YACrD,MAAM4B,iBAAiB,MAAMxG,qBAAqBwF,kBAAkB,CAAC;gBACnEV,UAAUxE,WAAWoD,EAAE;gBACvBD,YAAYpD,aAAaqD,EAAE;gBAC3BS,YAAY5D,aAAamD,EAAE;gBAC3BqB,QAAQvE,SAASkD,EAAE;gBACnBsB,eAAe;gBACfC,YAAY,IAAIC,KAAK;gBACrBC,oBAAoBC,yCAAkB,CAACc,MAAM;gBAC7CZ,kBAAkB;YACpB;YAEA,yCAAyC;YACzC,MAAM+G,kBAAkB;gBACtBrM,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;gBAC9D1D,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;gBAC9D1D,qBAAqB2G,qBAAqB,CAACH,eAAe9C,EAAE,EAAE;aAC/D;YAED,MAAM4I,UAAU,MAAMP,QAAQC,GAAG,CAACK;YAElC5G,OAAO6G,SAAShF,YAAY,CAAC;YAC7BgF,QAAQF,OAAO,CAACG,CAAAA;gBACd9G,OAAO8G,OAAO3F,OAAO,EAAEjB,IAAI,CAAC;gBAC5BF,OAAO8G,OAAO1F,UAAU,EAAElB,IAAI,CAACP,yCAAkB,CAACc,MAAM;YAC1D;YAEA,8BAA8B;YAC9B,MAAMkB,iBAAiB,MAAMnH,sBAAsBoH,yBAAyB,CAAChH,aAAaqD,EAAE;YAC5F+B,OAAO2B,gBAAgBE,YAAY,CAAC;YACpC7B,OAAO8B,WAAWH,cAAc,CAAC,EAAE,CAACI,aAAa,GAAG7B,IAAI,CAAC;YACzDF,OAAO2B,cAAc,CAAC,EAAE,CAACK,iBAAiB,EAAE9B,IAAI,CAAC;QACnD;IACF;AACF"}