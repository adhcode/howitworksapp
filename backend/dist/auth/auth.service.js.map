{"version":3,"sources":["../../src/auth/auth.service.ts"],"sourcesContent":["import { Injectable, UnauthorizedException, ConflictException, BadRequestException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport * as bcrypt from 'bcryptjs';\nimport * as crypto from 'crypto';\nimport { UsersService } from '../users/users.service';\nimport { EmailService } from '../email/email.service';\nimport { LoginDto, RegisterDto, AuthResponseDto } from './dto/auth.dto';\nimport { ChangePasswordDto } from './dto/change-password.dto';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private readonly usersService: UsersService,\n    private readonly jwtService: JwtService,\n    private readonly emailService: EmailService,\n  ) {}\n\n  async register(registerDto: RegisterDto): Promise<{ message: string; email: string }> {\n    // Check if user already exists\n    const existingUser = await this.usersService.findByEmail(registerDto.email);\n    if (existingUser) {\n      throw new ConflictException('User with this email already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(registerDto.password, 12);\n\n    // Generate 6-digit verification code\n    const emailVerificationCode = Math.floor(100000 + Math.random() * 900000).toString();\n    const emailVerificationCodeExpires = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes\n\n    // Create user with email verification code\n    const user = await this.usersService.create({\n      ...registerDto,\n      password: hashedPassword,\n      isEmailVerified: false,\n      emailVerificationCode,\n      emailVerificationCodeExpires,\n    });\n\n    // Send verification email with code\n    try {\n      await this.emailService.sendVerificationCodeEmail(\n        user.email,\n        user.firstName,\n        emailVerificationCode\n      );\n    } catch (error) {\n      console.error('Failed to send verification email:', error);\n      // Don't fail registration if email fails, just log it\n    }\n\n    return {\n      message: 'Registration successful. Please check your email for the verification code.',\n      email: user.email,\n    };\n  }\n\n  async login(loginDto: LoginDto): Promise<AuthResponseDto> {\n    // Find user by email\n    const user = await this.usersService.findByEmail(loginDto.email);\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Verify password\n    const isPasswordValid = await bcrypt.compare(loginDto.password, user.password);\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Check if user is active\n    if (!user.isActive) {\n      throw new UnauthorizedException('Account is deactivated');\n    }\n\n    // Check if email is verified\n    if (!user.isEmailVerified) {\n      throw new UnauthorizedException('Please verify your email address before logging in. Check your inbox for the verification link.');\n    }\n\n    // Update last login time\n    await this.usersService.updateLastLogin(user.id);\n\n    // Generate JWT token\n    const payload = { sub: user.id, email: user.email, role: user.role };\n    const accessToken = this.jwtService.sign(payload);\n\n    return {\n      user: {\n        id: user.id,\n        firstName: user.firstName,\n        lastName: user.lastName,\n        email: user.email,\n        role: user.role as any,\n      },\n      accessToken,\n    };\n  }\n\n  async registerWithInvitation(invitationData: {\n    token: string;\n    password: string;\n    phone: string;\n    emergencyContact?: string;\n    emergencyPhone?: string;\n  }): Promise<AuthResponseDto> {\n    // This method will be implemented when we inject TenantInvitationsService\n    // For now, we'll add a placeholder\n    throw new BadRequestException('Invitation-based registration not yet implemented');\n  }\n\n  async verifyEmail(token: string): Promise<{ message: string }> {\n    const user = await this.usersService.findByEmailVerificationToken(token);\n    \n    if (!user) {\n      throw new BadRequestException('Invalid or expired verification token');\n    }\n\n    if (user.isEmailVerified) {\n      throw new BadRequestException('Email is already verified');\n    }\n\n    // Update user to mark email as verified\n    await this.usersService.verifyEmail(user.id);\n\n    // Send welcome email\n    try {\n      await this.emailService.sendWelcomeEmail(user.email, user.firstName);\n    } catch (error) {\n      console.error('Failed to send welcome email:', error);\n    }\n\n    return {\n      message: 'Email verified successfully. You can now log in.',\n    };\n  }\n\n  async verifyEmailWithCode(email: string, code: string): Promise<{ message: string }> {\n    const user = await this.usersService.findByEmail(email);\n    \n    if (!user) {\n      throw new BadRequestException('User not found');\n    }\n\n    if (user.isEmailVerified) {\n      throw new BadRequestException('Email is already verified');\n    }\n\n    if (!user.emailVerificationCode || !user.emailVerificationCodeExpires) {\n      throw new BadRequestException('No verification code found. Please request a new one.');\n    }\n\n    // Check if code has expired\n    if (user.emailVerificationCodeExpires < new Date()) {\n      throw new BadRequestException('Verification code has expired. Please request a new one.');\n    }\n\n    // Verify the code\n    if (user.emailVerificationCode !== code) {\n      throw new BadRequestException('Invalid verification code');\n    }\n\n    // Update user to mark email as verified\n    await this.usersService.verifyEmail(user.id);\n\n    // Send welcome email\n    try {\n      await this.emailService.sendWelcomeEmail(user.email, user.firstName);\n    } catch (error) {\n      console.error('Failed to send welcome email:', error);\n    }\n\n    return {\n      message: 'Email verified successfully. You can now log in.',\n    };\n  }\n\n  async resendVerificationEmail(email: string): Promise<{ message: string }> {\n    const user = await this.usersService.findByEmail(email);\n    \n    if (!user) {\n      throw new BadRequestException('User not found');\n    }\n\n    if (user.isEmailVerified) {\n      throw new BadRequestException('Email is already verified');\n    }\n\n    // Generate new 6-digit verification code\n    const emailVerificationCode = Math.floor(100000 + Math.random() * 900000).toString();\n    const emailVerificationCodeExpires = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes\n\n    await this.usersService.updateEmailVerificationCode(user.id, emailVerificationCode, emailVerificationCodeExpires);\n\n    // Send verification email with code\n    try {\n      await this.emailService.sendVerificationCodeEmail(\n        user.email,\n        user.firstName,\n        emailVerificationCode\n      );\n    } catch (error) {\n      console.error('Failed to send verification email:', error);\n      throw new BadRequestException('Failed to send verification email');\n    }\n\n    return {\n      message: 'Verification code sent successfully.',\n    };\n  }\n\n  async testEmail(email: string, name: string): Promise<{ message: string }> {\n    // Generate a test token\n    const testToken = crypto.randomBytes(32).toString('hex');\n    \n    try {\n      await this.emailService.sendVerificationEmail(email, name, testToken);\n      return { message: 'Test email sent successfully' };\n    } catch (error) {\n      throw new BadRequestException(`Failed to send test email: ${error.message}`);\n    }\n  }\n\n  async manualVerifyEmail(email: string): Promise<{ message: string }> {\n    // For testing purposes only - manually verify an email without token\n    const user = await this.usersService.findByEmail(email);\n    \n    if (!user) {\n      throw new BadRequestException('User not found');\n    }\n\n    if (user.isEmailVerified) {\n      throw new BadRequestException('Email is already verified');\n    }\n\n    // Verify the email\n    await this.usersService.verifyEmail(user.id);\n\n    // Send welcome email\n    try {\n      await this.emailService.sendWelcomeEmail(user.email, user.firstName);\n    } catch (error) {\n      console.error('Failed to send welcome email:', error);\n    }\n\n    return {\n      message: 'Email verified successfully (manual verification for testing)',\n    };\n  }\n\n  async validateUser(userId: string) {\n    return this.usersService.findById(userId);\n  }\n\n  async getCurrentUser(userId: string) {\n    const user = await this.usersService.findById(userId);\n    \n    if (!user) {\n      throw new UnauthorizedException('User not found');\n    }\n\n    return {\n      id: user.id,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      email: user.email,\n      phoneNumber: user.phoneNumber,\n      role: user.role,\n      isActive: user.isActive,\n      isEmailVerified: user.isEmailVerified,\n      createdAt: user.createdAt,\n      updatedAt: user.updatedAt,\n      // Bank account details for landlords\n      bankAccountName: user.bankAccountName,\n      bankAccountNumber: user.bankAccountNumber,\n      bankCode: user.bankCode,\n      paystackRecipientCode: user.paystackRecipientCode,\n    };\n  }\n\n  async changePassword(userId: string, changePasswordDto: ChangePasswordDto): Promise<{ message: string }> {\n    try {\n      // Get user from database\n      const user = await this.usersService.findById(userId);\n      \n      if (!user) {\n        throw new UnauthorizedException('User not found');\n      }\n\n      // Verify current password\n      const isCurrentPasswordValid = await bcrypt.compare(\n        changePasswordDto.currentPassword,\n        user.password\n      );\n\n      if (!isCurrentPasswordValid) {\n        throw new UnauthorizedException('Current password is incorrect');\n      }\n\n      // Check if new password is same as current\n      if (changePasswordDto.currentPassword === changePasswordDto.newPassword) {\n        throw new BadRequestException('New password must be different from current password');\n      }\n\n      // Hash new password\n      const hashedPassword = await bcrypt.hash(changePasswordDto.newPassword, 12);\n\n      // Update password in database\n      await this.usersService.update(userId, { password: hashedPassword });\n\n      console.log(`âœ… Password changed successfully for user: ${userId}`);\n\n      return {\n        message: 'Password changed successfully',\n      };\n    } catch (error) {\n      console.error('Error changing password:', error);\n      throw error;\n    }\n  }\n\n  async forgotPassword(email: string): Promise<{ message: string }> {\n    const user = await this.usersService.findByEmail(email);\n    \n    // Don't reveal if user exists or not for security\n    if (!user) {\n      return {\n        message: 'If an account exists with this email, you will receive password reset instructions.',\n      };\n    }\n\n    // Generate 6-digit password reset code\n    const resetCode = Math.floor(100000 + Math.random() * 900000).toString();\n    const resetExpires = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes\n\n    // Store reset code\n    await this.usersService.updatePasswordResetCode(user.id, resetCode, resetExpires);\n\n    // Send password reset email with code\n    try {\n      await this.emailService.sendPasswordResetCodeEmail(\n        user.email,\n        user.firstName,\n        resetCode\n      );\n    } catch (error) {\n      console.error('Failed to send password reset email:', error);\n      throw new BadRequestException('Failed to send password reset email');\n    }\n\n    return {\n      message: 'If an account exists with this email, you will receive password reset instructions.',\n    };\n  }\n\n  async resetPassword(token: string, newPassword: string): Promise<{ message: string }> {\n    const user = await this.usersService.findByPasswordResetToken(token);\n    \n    if (!user) {\n      throw new BadRequestException('Invalid or expired reset token');\n    }\n\n    // Check if token has expired\n    if (!user.passwordResetExpires || user.passwordResetExpires < new Date()) {\n      throw new BadRequestException('Reset token has expired');\n    }\n\n    // Hash new password\n    const hashedPassword = await bcrypt.hash(newPassword, 12);\n\n    // Update password and clear reset token\n    await this.usersService.update(user.id, { password: hashedPassword });\n    await this.usersService.clearPasswordResetToken(user.id);\n\n    return {\n      message: 'Password has been reset successfully. You can now log in with your new password.',\n    };\n  }\n\n  async verifyResetCode(email: string, code: string): Promise<{ message: string; valid: boolean }> {\n    const user = await this.usersService.findByPasswordResetCode(email, code);\n    \n    if (!user) {\n      throw new BadRequestException('Invalid reset code');\n    }\n\n    // Check if code has expired\n    if (!user.passwordResetCodeExpires || user.passwordResetCodeExpires < new Date()) {\n      throw new BadRequestException('Reset code has expired. Please request a new one.');\n    }\n\n    return {\n      message: 'Reset code verified successfully',\n      valid: true,\n    };\n  }\n\n  async resetPasswordWithCode(email: string, code: string, newPassword: string): Promise<{ message: string }> {\n    const user = await this.usersService.findByPasswordResetCode(email, code);\n    \n    if (!user) {\n      throw new BadRequestException('Invalid reset code');\n    }\n\n    // Check if code has expired\n    if (!user.passwordResetCodeExpires || user.passwordResetCodeExpires < new Date()) {\n      throw new BadRequestException('Reset code has expired. Please request a new one.');\n    }\n\n    // Hash new password\n    const hashedPassword = await bcrypt.hash(newPassword, 12);\n\n    // Update password and clear reset code\n    await this.usersService.update(user.id, { password: hashedPassword });\n    await this.usersService.clearPasswordResetToken(user.id);\n\n    return {\n      message: 'Password has been reset successfully. You can now log in with your new password.',\n    };\n  }\n}"],"names":["AuthService","register","registerDto","existingUser","usersService","findByEmail","email","ConflictException","hashedPassword","bcrypt","hash","password","emailVerificationCode","Math","floor","random","toString","emailVerificationCodeExpires","Date","now","user","create","isEmailVerified","emailService","sendVerificationCodeEmail","firstName","error","console","message","login","loginDto","UnauthorizedException","isPasswordValid","compare","isActive","updateLastLogin","id","payload","sub","role","accessToken","jwtService","sign","lastName","registerWithInvitation","invitationData","BadRequestException","verifyEmail","token","findByEmailVerificationToken","sendWelcomeEmail","verifyEmailWithCode","code","resendVerificationEmail","updateEmailVerificationCode","testEmail","name","testToken","crypto","randomBytes","sendVerificationEmail","manualVerifyEmail","validateUser","userId","findById","getCurrentUser","phoneNumber","createdAt","updatedAt","bankAccountName","bankAccountNumber","bankCode","paystackRecipientCode","changePassword","changePasswordDto","isCurrentPasswordValid","currentPassword","newPassword","update","log","forgotPassword","resetCode","resetExpires","updatePasswordResetCode","sendPasswordResetCodeEmail","resetPassword","findByPasswordResetToken","passwordResetExpires","clearPasswordResetToken","verifyResetCode","findByPasswordResetCode","passwordResetCodeExpires","valid","resetPasswordWithCode"],"mappings":"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"}