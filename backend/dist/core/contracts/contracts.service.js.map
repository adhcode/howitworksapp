{"version":3,"sources":["../../../src/core/contracts/contracts.service.ts"],"sourcesContent":["import { Injectable, Inject, NotFoundException, BadRequestException, Logger } from '@nestjs/common';\nimport { PostgresJsDatabase } from 'drizzle-orm/postgres-js';\nimport { eq, and, or, gte, lte, sql } from 'drizzle-orm';\nimport { DATABASE_CONNECTION } from '../../database/database.module';\nimport * as schema from '../../database/schema';\nimport { \n  tenantRentContracts, \n  NewTenantRentContract,\n  TenantRentContract \n} from '../../database/schema/tenant-rent-contracts';\nimport { users, properties, units } from '../../database/schema';\nimport {\n  CreateNewTenantContractDto,\n  CreateExistingTenantContractDto,\n  UpdateContractDto,\n  ContractQueryDto,\n  LandlordPayoutType,\n} from './dto/create-contract.dto';\nimport { BUSINESS_RULES } from '../../shared/constants/business-rules.constant';\nimport { \n  startOfDay, \n  addMonths, \n  subMonths, \n  isBefore, \n  startOfMonth,\n  startOfNextMonth,\n  addDays,\n} from '../../shared/utils/date.utils';\n\n/**\n * CONTRACTS SERVICE\n * \n * Core service for managing rental contracts.\n * Handles both new tenants (fresh leases) and existing tenants (transitioning from another lease).\n * \n * Key responsibilities:\n * 1. Create contracts for new and existing tenants\n * 2. Calculate transition dates for existing tenants\n * 3. Calculate first payment due dates\n * 4. Manage contract lifecycle (active → expired → terminated)\n * 5. Validate contract data\n */\n@Injectable()\nexport class ContractsService {\n  private readonly logger = new Logger(ContractsService.name);\n\n  constructor(\n    @Inject(DATABASE_CONNECTION)\n    private readonly db: PostgresJsDatabase<typeof schema>,\n  ) {}\n\n  /**\n   * CREATE CONTRACT FOR NEW TENANT\n   * \n   * New tenant = starting fresh lease, no existing lease elsewhere\n   * \n   * Flow:\n   * 1. Validate tenant, landlord, property, unit exist\n   * 2. Check for duplicate active contracts\n   * 3. Calculate first payment due date (1st of move-in month or next month)\n   * 4. Create contract with status 'active'\n   * \n   * @param dto - New tenant contract data\n   * @returns Created contract\n   */\n  async createNewTenantContract(dto: CreateNewTenantContractDto): Promise<TenantRentContract> {\n    this.logger.log(`Creating new tenant contract for tenant ${dto.tenantId}`);\n\n    // Validate entities exist\n    await this.validateEntities(dto.tenantId, dto.landlordId, dto.propertyId, dto.unitId);\n\n    // Check for duplicate contracts\n    await this.checkDuplicateContract(dto.tenantId, dto.propertyId, dto.unitId);\n\n    // Parse dates\n    const leaseStart = startOfDay(new Date(dto.leaseStartDate));\n    const leaseEnd = startOfDay(new Date(dto.leaseEndDate));\n    const today = startOfDay(new Date());\n\n    // Validate lease dates\n    if (isBefore(leaseEnd, leaseStart)) {\n      throw new BadRequestException('Lease end date must be after start date');\n    }\n\n    // Calculate first payment due date\n    // Payment is due on the 1st of the month\n    // If lease starts on the 1st, payment due that day\n    // If lease starts mid-month, payment due on 1st of next month\n    const firstPaymentDue = this.calculateFirstPaymentDue(leaseStart);\n\n    // Create contract\n    const contractData: NewTenantRentContract = {\n      tenantId: dto.tenantId,\n      landlordId: dto.landlordId,\n      propertyId: dto.propertyId,\n      unitId: dto.unitId,\n      monthlyAmount: dto.monthlyAmount.toFixed(2),\n      expiryDate: leaseEnd,\n      landlordPayoutType: dto.landlordPayoutType,\n      nextPaymentDue: firstPaymentDue,\n      transitionStartDate: leaseStart, // For new tenants, transition is same as lease start\n      status: 'active',\n      isExistingTenant: false,\n      originalExpiryDate: null,\n    };\n\n    const [contract] = await this.db\n      .insert(tenantRentContracts)\n      .values(contractData)\n      .returning();\n\n    this.logger.log(`✅ Contract created: ${contract.id} | First payment due: ${firstPaymentDue.toDateString()}`);\n\n    return contract;\n  }\n\n  /**\n   * CREATE CONTRACT FOR EXISTING TENANT\n   * \n   * Existing tenant = already has active lease elsewhere, transitioning to Homezy\n   * \n   * Key business logic:\n   * - If landlord wants MONTHLY payout: tenant starts paying 3 months before current lease expires\n   * - If landlord wants YEARLY payout: tenant starts paying 6 months before current lease expires\n   * - If transition date has passed, start immediately\n   * \n   * Flow:\n   * 1. Validate entities\n   * 2. Calculate transition start date based on payout type\n   * 3. If transition date passed, start immediately\n   * 4. Calculate first payment due (1st of month)\n   * 5. Set new lease end date (default: 1 year after current lease expiry)\n   * \n   * @param dto - Existing tenant contract data\n   * @returns Created contract\n   */\n  async createExistingTenantContract(dto: CreateExistingTenantContractDto): Promise<TenantRentContract> {\n    this.logger.log(`Creating existing tenant contract for tenant ${dto.tenantId}`);\n\n    // Validate entities exist\n    await this.validateEntities(dto.tenantId, dto.landlordId, dto.propertyId, dto.unitId);\n\n    // Check for duplicate contracts\n    await this.checkDuplicateContract(dto.tenantId, dto.propertyId, dto.unitId);\n\n    // Parse dates\n    const currentLeaseExpiry = startOfDay(new Date(dto.currentLeaseExpiryDate));\n    const today = startOfDay(new Date());\n\n    // Validate current lease expiry is in the future\n    if (isBefore(currentLeaseExpiry, today)) {\n      throw new BadRequestException('Current lease expiry must be in the future');\n    }\n\n    // Calculate transition start date based on payout type\n    const transitionStart = this.calculateTransitionStartDate(\n      currentLeaseExpiry,\n      dto.landlordPayoutType\n    );\n\n    this.logger.log(`Transition calculation:`);\n    this.logger.log(`  Current lease expires: ${currentLeaseExpiry.toDateString()}`);\n    this.logger.log(`  Payout type: ${dto.landlordPayoutType}`);\n    this.logger.log(`  Transition starts: ${transitionStart.toDateString()}`);\n    this.logger.log(`  Started ${isBefore(transitionStart, today) ? 'IMMEDIATELY' : 'in the FUTURE'}`);\n\n    // Calculate first payment due date (1st of month)\n    const firstPaymentDue = this.calculateFirstPaymentDue(transitionStart);\n\n    // Determine new lease end date\n    // Default: 1 year after current lease expiry\n    const newLeaseEnd = dto.newLeaseEndDate\n      ? startOfDay(new Date(dto.newLeaseEndDate))\n      : addMonths(currentLeaseExpiry, 12);\n\n    // Create contract\n    const contractData: NewTenantRentContract = {\n      tenantId: dto.tenantId,\n      landlordId: dto.landlordId,\n      propertyId: dto.propertyId,\n      unitId: dto.unitId,\n      monthlyAmount: dto.monthlyAmount.toFixed(2),\n      expiryDate: newLeaseEnd,\n      landlordPayoutType: dto.landlordPayoutType,\n      nextPaymentDue: firstPaymentDue,\n      transitionStartDate: transitionStart,\n      status: 'active',\n      isExistingTenant: true,\n      originalExpiryDate: currentLeaseExpiry,\n    };\n\n    const [contract] = await this.db\n      .insert(tenantRentContracts)\n      .values(contractData)\n      .returning();\n\n    this.logger.log(`✅ Existing tenant contract created: ${contract.id}`);\n    this.logger.log(`   First payment due: ${firstPaymentDue.toDateString()}`);\n    this.logger.log(`   New lease ends: ${newLeaseEnd.toDateString()}`);\n\n    return contract;\n  }\n\n  /**\n   * CALCULATE TRANSITION START DATE FOR EXISTING TENANTS\n   * \n   * Business rule:\n   * - Monthly payout → Start 3 months before lease expiry\n   * - Yearly payout → Start 6 months before lease expiry\n   * - If calculated date is in the past → Start immediately (today)\n   * \n   * @param leaseExpiryDate - When current lease expires\n   * @param payoutType - Monthly or yearly\n   * @returns Date when tenant should start paying\n   */\n  private calculateTransitionStartDate(\n    leaseExpiryDate: Date,\n    payoutType: LandlordPayoutType\n  ): Date {\n    const monthsBeforeExpiry =\n      payoutType === LandlordPayoutType.MONTHLY\n        ? BUSINESS_RULES.TRANSITION_PERIODS.MONTHLY_PAYOUT\n        : BUSINESS_RULES.TRANSITION_PERIODS.YEARLY_PAYOUT;\n\n    // Calculate X months before expiry\n    const transitionDate = subMonths(leaseExpiryDate, monthsBeforeExpiry);\n\n    // If that date has passed, start immediately\n    const today = startOfDay(new Date());\n\n    return isBefore(transitionDate, today) ? today : transitionDate;\n  }\n\n  /**\n   * CALCULATE FIRST PAYMENT DUE DATE\n   * \n   * Business rule: Payments are due on the 1st of each month\n   * \n   * Logic:\n   * - If transition/lease starts on the 1st → Payment due that day\n   * - If transition/lease starts mid-month → Payment due on 1st of NEXT month\n   * - If transition/lease starts after today → Payment due on 1st of that month or next\n   * \n   * @param startDate - Lease start or transition start date\n   * @returns First payment due date (always 1st of month)\n   */\n  private calculateFirstPaymentDue(startDate: Date): Date {\n    const today = startOfDay(new Date());\n    const effectiveStart = isBefore(startDate, today) ? today : startDate;\n\n    // If starting on the 1st, payment due that day\n    if (effectiveStart.getDate() === BUSINESS_RULES.PAYMENT_DUE_DAY) {\n      return effectiveStart;\n    }\n\n    // Otherwise, payment due on 1st of next month\n    return startOfNextMonth(effectiveStart);\n  }\n\n  /**\n   * GET CONTRACT BY ID\n   */\n  async getContractById(contractId: string): Promise<TenantRentContract> {\n    const [contract] = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(eq(tenantRentContracts.id, contractId))\n      .limit(1);\n\n    if (!contract) {\n      throw new NotFoundException(`Contract ${contractId} not found`);\n    }\n\n    return contract;\n  }\n\n  /**\n   * GET CONTRACTS BY QUERY\n   */\n  async getContracts(query: ContractQueryDto): Promise<TenantRentContract[]> {\n    const conditions: any[] = [];\n\n    if (query.tenantId) {\n      conditions.push(eq(tenantRentContracts.tenantId, query.tenantId));\n    }\n\n    if (query.landlordId) {\n      conditions.push(eq(tenantRentContracts.landlordId, query.landlordId));\n    }\n\n    if (query.propertyId) {\n      conditions.push(eq(tenantRentContracts.propertyId, query.propertyId));\n    }\n\n    if (query.status) {\n      conditions.push(eq(tenantRentContracts.status, query.status as any));\n    }\n\n    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n\n    return this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(whereClause)\n      .orderBy(sql`${tenantRentContracts.createdAt} DESC`);\n  }\n\n  /**\n   * UPDATE CONTRACT\n   */\n  async updateContract(\n    contractId: string,\n    dto: UpdateContractDto\n  ): Promise<TenantRentContract> {\n    const contract = await this.getContractById(contractId);\n\n    const updateData: Partial<NewTenantRentContract> = {\n      updatedAt: new Date(),\n    };\n\n    if (dto.monthlyAmount !== undefined) {\n      updateData.monthlyAmount = dto.monthlyAmount.toFixed(2);\n    }\n\n    if (dto.leaseEndDate !== undefined) {\n      updateData.expiryDate = startOfDay(new Date(dto.leaseEndDate));\n    }\n\n    if (dto.landlordPayoutType !== undefined) {\n      updateData.landlordPayoutType = dto.landlordPayoutType;\n    }\n\n    const [updated] = await this.db\n      .update(tenantRentContracts)\n      .set(updateData)\n      .where(eq(tenantRentContracts.id, contractId))\n      .returning();\n\n    this.logger.log(`✅ Contract updated: ${contractId}`);\n\n    return updated;\n  }\n\n  /**\n   * TERMINATE CONTRACT\n   */\n  async terminateContract(contractId: string): Promise<TenantRentContract> {\n    const contract = await this.getContractById(contractId);\n\n    const [terminated] = await this.db\n      .update(tenantRentContracts)\n      .set({\n        status: 'terminated',\n        updatedAt: new Date(),\n      })\n      .where(eq(tenantRentContracts.id, contractId))\n      .returning();\n\n    this.logger.log(`✅ Contract terminated: ${contractId}`);\n\n    return terminated;\n  }\n\n  /**\n   * VALIDATE ENTITIES EXIST\n   * Private helper to validate tenant, landlord, property, unit exist\n   */\n  private async validateEntities(\n    tenantId: string,\n    landlordId: string,\n    propertyId: string,\n    unitId: string\n  ): Promise<void> {\n    // Validate tenant exists\n    const [tenant] = await this.db\n      .select()\n      .from(users)\n      .where(and(eq(users.id, tenantId), eq(users.role, 'tenant')))\n      .limit(1);\n\n    if (!tenant) {\n      throw new NotFoundException(`Tenant ${tenantId} not found`);\n    }\n\n    // Validate landlord exists\n    const [landlord] = await this.db\n      .select()\n      .from(users)\n      .where(and(eq(users.id, landlordId), eq(users.role, 'landlord')))\n      .limit(1);\n\n    if (!landlord) {\n      throw new NotFoundException(`Landlord ${landlordId} not found`);\n    }\n\n    // Validate property exists and belongs to landlord\n    const [property] = await this.db\n      .select()\n      .from(properties)\n      .where(and(\n        eq(properties.id, propertyId),\n        eq(properties.landlordId, landlordId)\n      ))\n      .limit(1);\n\n    if (!property) {\n      throw new NotFoundException(\n        `Property ${propertyId} not found or doesn't belong to landlord ${landlordId}`\n      );\n    }\n\n    // Validate unit exists and belongs to property\n    const [unit] = await this.db\n      .select()\n      .from(units)\n      .where(and(\n        eq(units.id, unitId),\n        eq(units.propertyId, propertyId)\n      ))\n      .limit(1);\n\n    if (!unit) {\n      throw new NotFoundException(\n        `Unit ${unitId} not found or doesn't belong to property ${propertyId}`\n      );\n    }\n  }\n\n  /**\n   * CHECK FOR DUPLICATE CONTRACT\n   * Private helper to ensure tenant doesn't have multiple active contracts for same unit\n   */\n  private async checkDuplicateContract(\n    tenantId: string,\n    propertyId: string,\n    unitId: string\n  ): Promise<void> {\n    const [existing] = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(\n        and(\n          eq(tenantRentContracts.tenantId, tenantId),\n          eq(tenantRentContracts.propertyId, propertyId),\n          eq(tenantRentContracts.unitId, unitId),\n          eq(tenantRentContracts.status, 'active')\n        )\n      )\n      .limit(1);\n\n    if (existing) {\n      throw new BadRequestException(\n        `Tenant already has an active contract for this unit. Contract ID: ${existing.id}`\n      );\n    }\n  }\n}\n\n"],"names":["ContractsService","createNewTenantContract","dto","logger","log","tenantId","validateEntities","landlordId","propertyId","unitId","checkDuplicateContract","leaseStart","startOfDay","Date","leaseStartDate","leaseEnd","leaseEndDate","today","isBefore","BadRequestException","firstPaymentDue","calculateFirstPaymentDue","contractData","monthlyAmount","toFixed","expiryDate","landlordPayoutType","nextPaymentDue","transitionStartDate","status","isExistingTenant","originalExpiryDate","contract","db","insert","tenantRentContracts","values","returning","id","toDateString","createExistingTenantContract","currentLeaseExpiry","currentLeaseExpiryDate","transitionStart","calculateTransitionStartDate","newLeaseEnd","newLeaseEndDate","addMonths","leaseExpiryDate","payoutType","monthsBeforeExpiry","LandlordPayoutType","MONTHLY","BUSINESS_RULES","TRANSITION_PERIODS","MONTHLY_PAYOUT","YEARLY_PAYOUT","transitionDate","subMonths","startDate","effectiveStart","getDate","PAYMENT_DUE_DAY","startOfNextMonth","getContractById","contractId","select","from","where","eq","limit","NotFoundException","getContracts","query","conditions","push","whereClause","length","and","undefined","orderBy","sql","createdAt","updateContract","updateData","updatedAt","updated","update","set","terminateContract","terminated","tenant","users","role","landlord","property","properties","unit","units","existing","Logger","name"],"mappings":"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"}