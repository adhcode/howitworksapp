{"version":3,"sources":["../../../src/core/payments/payment-processor.service.ts"],"sourcesContent":["import { Injectable, Inject, BadRequestException, Logger, NotFoundException } from '@nestjs/common';\nimport { PostgresJsDatabase } from 'drizzle-orm/postgres-js';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { DATABASE_CONNECTION } from '../../database/database.module';\nimport * as schema from '../../database/schema';\nimport { \n  tenantRentContracts,\n  landlordEscrowBalances,\n  NewLandlordEscrowBalance,\n} from '../../database/schema/tenant-rent-contracts';\nimport { payments, NewPayment } from '../../database/schema/payments';\nimport { users } from '../../database/schema/users';\nimport { ProcessPaymentDto, PaymentResultDto } from './dto/payment.dto';\nimport { BUSINESS_RULES } from '../../shared/constants/business-rules.constant';\nimport { addMonths, startOfMonth, differenceInMonths } from '../../shared/utils/date.utils';\nimport { PaystackService } from './paystack.service';\nimport { WalletService } from '../wallet/wallet.service';\n\n/**\n * PAYMENT PROCESSOR SERVICE\n * \n * Core service for processing rent payments with Paystack integration.\n * Handles the flow of money from tenant to either:\n * 1. Landlord wallet (immediate payout for monthly via Paystack Transfer)\n * 2. Escrow account (accumulation for yearly)\n * \n * Key responsibilities:\n * 1. Initialize payments with Paystack\n * 2. Verify and process payments\n * 3. Route money based on payout type\n * 4. Handle recurring payments (saved cards)\n * 5. Manage landlord payouts/transfers\n * 6. Update contract payment due dates\n */\n@Injectable()\nexport class PaymentProcessorService {\n  private readonly logger = new Logger(PaymentProcessorService.name);\n\n  constructor(\n    @Inject(DATABASE_CONNECTION)\n    private readonly db: PostgresJsDatabase<typeof schema>,\n    private readonly paystackService: PaystackService,\n    private readonly walletService: WalletService,\n  ) {}\n\n  /**\n   * PROCESS RENT PAYMENT\n   * \n   * Main payment processing flow:\n   * 1. Validate contract exists and is active\n   * 2. Verify payment amount matches monthly rent\n   * 3. Route payment based on landlord payout type:\n   *    - MONTHLY ‚Üí Immediate payout to landlord wallet\n   *    - YEARLY ‚Üí Add to escrow for later release\n   * 4. Create payment record\n   * 5. Update next payment due date\n   * \n   * @param dto - Payment details\n   * @returns Payment result\n   */\n  async processPayment(dto: ProcessPaymentDto): Promise<PaymentResultDto> {\n    this.logger.log(`Processing payment for contract ${dto.contractId}`);\n\n    // Get contract\n    const [contract] = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(eq(tenantRentContracts.id, dto.contractId))\n      .limit(1);\n\n    if (!contract) {\n      throw new BadRequestException(`Contract ${dto.contractId} not found`);\n    }\n\n    if (contract.status !== 'active') {\n      throw new BadRequestException(`Contract is not active. Status: ${contract.status}`);\n    }\n\n    // Verify payment amount\n    const expectedAmount = parseFloat(contract.monthlyAmount);\n    if (Math.abs(dto.amount - expectedAmount) > 0.01) { // Allow 1 cent difference for rounding\n      throw new BadRequestException(\n        `Payment amount ${dto.amount} does not match contract amount ${expectedAmount}`\n      );\n    }\n\n    try {\n      let payoutMessage: string;\n      let transactionId: string | undefined;\n\n      // Route payment based on payout type\n      if (contract.landlordPayoutType === 'monthly') {\n        // Immediate payout to landlord\n        transactionId = await this.processImmediatePayout(\n          contract.landlordId,\n          dto.amount,\n          dto.contractId,\n          dto.paymentMethod,\n          dto.reference\n        );\n        payoutMessage = 'Payment credited immediately to landlord wallet';\n      } else {\n        // Add to escrow\n        await this.addToEscrow(\n          contract.landlordId,\n          dto.amount,\n          dto.contractId\n        );\n        payoutMessage = 'Payment added to escrow for yearly release';\n      }\n\n      // Create payment record\n      await this.createPaymentRecord(contract, dto);\n\n      // Update next payment due date (add 1 month)\n      const nextPaymentDue = addMonths(contract.nextPaymentDue, 1);\n      await this.updateNextPaymentDue(dto.contractId, nextPaymentDue);\n\n      this.logger.log(`‚úÖ Payment processed successfully for contract ${dto.contractId}`);\n      this.logger.log(`   Amount: $${dto.amount}`);\n      this.logger.log(`   Payout type: ${contract.landlordPayoutType}`);\n      this.logger.log(`   Next payment due: ${nextPaymentDue.toDateString()}`);\n\n      return {\n        success: true,\n        payoutType: contract.landlordPayoutType,\n        message: payoutMessage,\n        nextPaymentDue,\n        transactionId,\n      };\n    } catch (error) {\n      this.logger.error(`‚ùå Payment processing failed: ${error.message}`, error.stack);\n      throw new BadRequestException(`Payment processing failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * PROCESS IMMEDIATE PAYOUT (MONTHLY)\n   * \n   * Credits landlord's wallet immediately when tenant pays.\n   * \n   * TODO: Integrate with actual wallet/banking system\n   * For now, logs the transaction.\n   * \n   * @param landlordId - Landlord to pay\n   * @param amount - Amount to credit\n   * @param contractId - Related contract\n   * @param paymentMethod - How tenant paid\n   * @param reference - Payment reference\n   * @returns Transaction ID\n   */\n  private async processImmediatePayout(\n    landlordId: string,\n    amount: number,\n    contractId: string,\n    paymentMethod?: string,\n    reference?: string\n  ): Promise<string> {\n    this.logger.log(`üí∞ Immediate payout: ‚Ç¶${amount} to landlord ${landlordId}`);\n\n    // Credit landlord's wallet using WalletService\n    const transaction = await this.walletService.credit(landlordId, amount, {\n      type: 'rent_payment',\n      contractId,\n      reference,\n      description: `Rent payment received via ${paymentMethod || 'card'}`,\n    });\n\n    this.logger.log(`‚úÖ Landlord wallet credited. Transaction ID: ${transaction.id}`);\n    this.logger.log(`   Balance updated for landlord ${landlordId}`);\n\n    return transaction.id;\n  }\n\n  /**\n   * ADD TO ESCROW (YEARLY)\n   * \n   * Adds payment to escrow balance for yearly payout landlords.\n   * Money accumulates until:\n   * - 12 months have passed, OR\n   * - Contract expires\n   * Then it's released to landlord wallet.\n   * \n   * @param landlordId - Landlord ID\n   * @param amount - Amount to add\n   * @param contractId - Related contract\n   */\n  private async addToEscrow(\n    landlordId: string,\n    amount: number,\n    contractId: string\n  ): Promise<void> {\n    this.logger.log(`üè¶ Adding $${amount} to escrow for landlord ${landlordId}`);\n\n    // Check if escrow balance exists for this contract\n    const [existingEscrow] = await this.db\n      .select()\n      .from(landlordEscrowBalances)\n      .where(\n        and(\n          eq(landlordEscrowBalances.contractId, contractId),\n          eq(landlordEscrowBalances.landlordId, landlordId),\n          eq(landlordEscrowBalances.isReleased, false)\n        )\n      )\n      .limit(1);\n\n    if (existingEscrow) {\n      // Update existing escrow\n      const newTotal = parseFloat(existingEscrow.totalEscrowed) + amount;\n      const newMonthsAccumulated = existingEscrow.monthsAccumulated + 1;\n\n      await this.db\n        .update(landlordEscrowBalances)\n        .set({\n          totalEscrowed: newTotal.toFixed(2),\n          monthsAccumulated: newMonthsAccumulated,\n          updatedAt: new Date(),\n        })\n        .where(eq(landlordEscrowBalances.id, existingEscrow.id));\n\n      this.logger.log(`‚úÖ Escrow updated: $${newTotal} (${newMonthsAccumulated} months)`);\n    } else {\n      // Create new escrow balance\n      // Expected release date: 12 months from now\n      const expectedReleaseDate = addMonths(new Date(), BUSINESS_RULES.ESCROW.AUTO_RELEASE_MONTHS);\n\n      const escrowData: NewLandlordEscrowBalance = {\n        landlordId,\n        contractId,\n        totalEscrowed: amount.toFixed(2),\n        monthsAccumulated: 1,\n        expectedReleaseDate,\n        isReleased: false,\n      };\n\n      await this.db\n        .insert(landlordEscrowBalances)\n        .values(escrowData);\n\n      this.logger.log(`‚úÖ New escrow created: $${amount} | Release date: ${expectedReleaseDate.toDateString()}`);\n    }\n  }\n\n  /**\n   * CREATE PAYMENT RECORD\n   * \n   * Records payment in the payments table for tracking and history.\n   * \n   * @param contract - Related contract\n   * @param dto - Payment details\n   */\n  private async createPaymentRecord(\n    contract: typeof tenantRentContracts.$inferSelect,\n    dto: ProcessPaymentDto\n  ): Promise<void> {\n    const paymentData: NewPayment = {\n      landlordId: contract.landlordId,\n      tenantId: contract.tenantId,\n      propertyId: contract.propertyId,\n      unitId: contract.unitId,\n      amount: dto.amount.toFixed(2),\n      amountPaid: dto.amount.toFixed(2),\n      dueDate: contract.nextPaymentDue,\n      paidDate: new Date(),\n      paymentType: 'rent',\n      paymentMethod: dto.paymentMethod as any,\n      status: 'paid',\n      receiptNumber: dto.reference,\n      description: `Rent payment for ${startOfMonth(contract.nextPaymentDue).toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`,\n      notes: dto.reference,\n    };\n\n    await this.db.insert(payments).values(paymentData);\n\n    this.logger.log(`‚úÖ Payment record created`);\n  }\n\n  /**\n   * UPDATE NEXT PAYMENT DUE DATE\n   * \n   * After payment, advances the next payment due date by 1 month.\n   * \n   * @param contractId - Contract ID\n   * @param nextPaymentDue - New due date\n   */\n  private async updateNextPaymentDue(\n    contractId: string,\n    nextPaymentDue: Date\n  ): Promise<void> {\n    await this.db\n      .update(tenantRentContracts)\n      .set({\n        nextPaymentDue,\n        updatedAt: new Date(),\n      })\n      .where(eq(tenantRentContracts.id, contractId));\n\n    this.logger.log(`‚úÖ Next payment due updated to: ${nextPaymentDue.toDateString()}`);\n  }\n\n  /**\n   * GET PAYMENT HISTORY FOR TENANT\n   * \n   * Returns all payments made by a tenant across all their contracts.\n   * \n   * @param tenantId - Tenant ID\n   * @returns Payment history\n   */\n  async getPaymentHistory(tenantId: string): Promise<any[]> {\n    return this.db\n      .select()\n      .from(payments)\n      .where(and(\n        eq(payments.tenantId, tenantId),\n        eq(payments.status, 'paid')\n      ))\n      .orderBy(sql`${payments.paidDate} DESC`);\n  }\n\n  /**\n   * GET UPCOMING PAYMENTS FOR TENANT\n   * \n   * Returns all upcoming (pending) payments for a tenant.\n   * \n   * @param tenantId - Tenant ID\n   * @returns Upcoming payments\n   */\n  async getUpcomingPayments(tenantId: string): Promise<any[]> {\n    const contracts = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(and(\n        eq(tenantRentContracts.tenantId, tenantId),\n        eq(tenantRentContracts.status, 'active')\n      ));\n\n    return contracts.map(contract => ({\n      contractId: contract.id,\n      propertyId: contract.propertyId,\n      unitId: contract.unitId,\n      amount: contract.monthlyAmount,\n      dueDate: contract.nextPaymentDue,\n      status: this.getPaymentStatus(contract.nextPaymentDue),\n    }));\n  }\n\n  /**\n   * GET PAYMENT STATUS\n   * \n   * Determines if payment is pending, due, or overdue based on dates.\n   * \n   * @param dueDate - Payment due date\n   * @returns Status string\n   */\n  private getPaymentStatus(dueDate: Date): 'upcoming' | 'due' | 'overdue' {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    const due = new Date(dueDate);\n    due.setHours(0, 0, 0, 0);\n\n    const diffDays = Math.floor((due.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));\n\n    if (diffDays < -BUSINESS_RULES.PAYMENT_GRACE_DAYS) {\n      return 'overdue';\n    } else if (diffDays <= 0) {\n      return 'due';\n    } else {\n      return 'upcoming';\n    }\n  }\n\n  // ==========================================\n  // PAYSTACK-INTEGRATED METHODS\n  // ==========================================\n\n  /**\n   * INITIALIZE PAYMENT WITH PAYSTACK\n   * \n   * Step 1: Initialize payment transaction with Paystack.\n   * Returns authorization URL for tenant to complete payment.\n   * \n   * @param contractId - Contract to pay for\n   * @param tenantEmail - Tenant's email\n   * @returns Paystack authorization URL and reference\n   */\n  async initializePayment(contractId: string, tenantEmail: string): Promise<{\n    success: boolean;\n    message: string;\n    authorization_url?: string;\n    reference?: string;\n    amount?: number;\n  }> {\n    this.logger.log(`üí≥ Initializing payment for contract ${contractId}`);\n\n    // Get contract\n    const [contract] = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(eq(tenantRentContracts.id, contractId))\n      .limit(1);\n\n    if (!contract) {\n      throw new NotFoundException(`Contract ${contractId} not found`);\n    }\n\n    if (contract.status !== 'active') {\n      throw new BadRequestException(`Contract is not active`);\n    }\n\n    const amount = parseFloat(contract.monthlyAmount);\n    const reference = this.paystackService.generateReference();\n\n    // Initialize with Paystack\n    const paystackResponse = await this.paystackService.initializeTransaction({\n      email: tenantEmail,\n      amount: amount,\n      reference: reference,\n      callback_url: `${process.env.FRONTEND_URL}/payments/callback`,\n      metadata: {\n        contractId: contract.id,\n        tenantId: contract.tenantId,\n        landlordId: contract.landlordId,\n        propertyId: contract.propertyId,\n        unitId: contract.unitId,\n        payoutType: contract.landlordPayoutType,\n        type: 'rent_payment',\n      },\n    });\n\n    if (!paystackResponse.status || !paystackResponse.data) {\n      throw new BadRequestException(paystackResponse.message || 'Payment initialization failed');\n    }\n\n    this.logger.log(`‚úÖ Payment initialized: ${reference}`);\n\n    return {\n      success: true,\n      message: 'Payment initialized successfully',\n      authorization_url: paystackResponse.data.authorization_url,\n      reference: reference,\n      amount: amount,\n    };\n  }\n\n  /**\n   * COMPLETE PAYMENT AFTER PAYSTACK VERIFICATION\n   * \n   * Step 2: Verify payment with Paystack and process through business logic.\n   * Called by webhook or callback handler.\n   * \n   * @param reference - Paystack payment reference\n   * @returns Payment result\n   */\n  async completePayment(reference: string): Promise<PaymentResultDto> {\n    this.logger.log(`üîç Completing payment: ${reference}`);\n\n    // Verify transaction with Paystack\n    const verification = await this.paystackService.verifyTransaction(reference);\n\n    if (!verification.status || !verification.data) {\n      throw new BadRequestException(verification.message || 'Payment verification failed');\n    }\n\n    if (verification.data.status !== 'success') {\n      throw new BadRequestException(`Payment failed: ${verification.data.gateway_response}`);\n    }\n\n    // Extract contract details from metadata\n    const metadata = verification.data.metadata;\n    const contractId = metadata.contractId;\n    const amount = verification.data.amount; // Already converted from kobo in verifyTransaction\n\n    // Save authorization code if card is reusable (for recurring payments)\n    if (verification.data.authorization?.reusable) {\n      await this.savePaymentAuthorization(\n        metadata.tenantId,\n        verification.data.authorization\n      );\n    }\n\n    // Process payment using existing business logic\n    return this.processPayment({\n      contractId: contractId,\n      amount: amount,\n      paymentMethod: verification.data.channel,\n      reference: reference,\n    });\n  }\n\n  /**\n   * CHARGE RECURRING PAYMENT (SAVED CARD)\n   * \n   * Charges tenant's saved card automatically for recurring payments.\n   * \n   * @param contractId - Contract to charge for\n   * @param tenantId - Tenant who owns the card\n   * @returns Payment result\n   */\n  async chargeRecurringPayment(contractId: string, tenantId: string): Promise<PaymentResultDto> {\n    this.logger.log(`üîÑ Processing recurring payment for contract ${contractId}`);\n\n    // Get contract\n    const [contract] = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(eq(tenantRentContracts.id, contractId))\n      .limit(1);\n\n    if (!contract) {\n      throw new NotFoundException(`Contract ${contractId} not found`);\n    }\n\n    if (contract.tenantId !== tenantId) {\n      throw new BadRequestException(`Contract does not belong to this tenant`);\n    }\n\n    // Get tenant's saved authorization\n    const [tenant] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, tenantId))\n      .limit(1);\n\n    if (!tenant || !tenant.paystackAuthorizationCode) {\n      throw new BadRequestException(`No saved payment method found for this tenant`);\n    }\n\n    const amount = parseFloat(contract.monthlyAmount);\n    const reference = this.paystackService.generateReference('recurring');\n\n    // Charge the saved card\n    const chargeResponse = await this.paystackService.chargeAuthorization({\n      email: tenant.email,\n      amount: amount,\n      authorization_code: tenant.paystackAuthorizationCode,\n      reference: reference,\n      metadata: {\n        contractId: contract.id,\n        tenantId: contract.tenantId,\n        landlordId: contract.landlordId,\n        type: 'recurring_rent_payment',\n      },\n    });\n\n    if (!chargeResponse.status) {\n      this.logger.error(`‚ùå Recurring payment failed: ${chargeResponse.message}`);\n      throw new BadRequestException(`Recurring payment failed: ${chargeResponse.message}`);\n    }\n\n    // Process payment\n    return this.processPayment({\n      contractId: contractId,\n      amount: amount,\n      paymentMethod: 'card_recurring',\n      reference: reference,\n    });\n  }\n\n  /**\n   * SAVE PAYMENT AUTHORIZATION (CARD DETAILS)\n   * \n   * Saves tenant's card authorization for recurring payments.\n   * \n   * @param tenantId - Tenant ID\n   * @param authorization - Paystack authorization object\n   */\n  private async savePaymentAuthorization(tenantId: string, authorization: any): Promise<void> {\n    if (!authorization.reusable) {\n      return; // Don't save if not reusable\n    }\n\n    this.logger.log(`üí≥ Saving payment method for tenant ${tenantId}`);\n\n    await this.db\n      .update(users)\n      .set({\n        paystackAuthorizationCode: authorization.authorization_code,\n        paystackCardLast4: authorization.last4,\n        paystackCardBrand: authorization.brand,\n        paystackCardBank: authorization.bank,\n        updatedAt: new Date(),\n      })\n      .where(eq(users.id, tenantId));\n\n    this.logger.log(`‚úÖ Payment method saved for tenant ${tenantId}`);\n  }\n\n  /**\n   * PROCESS LANDLORD PAYOUT\n   * \n   * Transfers money to landlord's bank account via Paystack.\n   * \n   * @param landlordId - Landlord to pay out\n   * @param amount - Amount to transfer\n   * @param reason - Reason for transfer\n   * @returns Transfer result\n   */\n  async processLandlordPayout(\n    landlordId: string,\n    amount: number,\n    reason: string = 'Rent payout'\n  ): Promise<{\n    success: boolean;\n    message: string;\n    transfer_code?: string;\n    reference?: string;\n  }> {\n    this.logger.log(`üí∏ Processing landlord payout: ${landlordId} - ‚Ç¶${amount}`);\n\n    // Get landlord details\n    const [landlord] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, landlordId))\n      .limit(1);\n\n    if (!landlord) {\n      throw new NotFoundException(`Landlord ${landlordId} not found`);\n    }\n\n    // Check if landlord has recipient code\n    if (!landlord.paystackRecipientCode) {\n      throw new BadRequestException(\n        `Landlord must set up bank account before receiving payouts`\n      );\n    }\n\n    // Initiate transfer\n    const transferResponse = await this.paystackService.initiateTransfer({\n      amount: amount,\n      recipient: landlord.paystackRecipientCode,\n      reason: reason,\n      metadata: {\n        landlordId: landlord.id,\n        type: 'landlord_payout',\n      },\n    });\n\n    if (!transferResponse.status) {\n      this.logger.error(`‚ùå Payout failed: ${transferResponse.message}`);\n      throw new BadRequestException(`Payout failed: ${transferResponse.message}`);\n    }\n\n    this.logger.log(`‚úÖ Payout initiated: ${transferResponse.data?.transfer_code}`);\n\n    return {\n      success: true,\n      message: 'Payout initiated successfully',\n      transfer_code: transferResponse.data?.transfer_code,\n      reference: transferResponse.data?.reference,\n    };\n  }\n\n  /**\n   * SETUP LANDLORD BANK ACCOUNT\n   * \n   * Creates transfer recipient for landlord payouts.\n   * \n   * @param landlordId - Landlord ID\n   * @param bankDetails - Bank account details\n   * @returns Recipient code\n   */\n  async setupLandlordBankAccount(\n    landlordId: string,\n    bankDetails: {\n      account_number: string;\n      bank_code: string;\n    }\n  ): Promise<{\n    success: boolean;\n    message: string;\n    recipient_code?: string;\n  }> {\n    this.logger.log(`üè¶ Setting up bank account for landlord ${landlordId}`);\n\n    // Get landlord\n    const [landlord] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, landlordId))\n      .limit(1);\n\n    if (!landlord) {\n      throw new NotFoundException(`Landlord ${landlordId} not found`);\n    }\n\n    // Resolve account number first\n    const accountDetails = await this.paystackService.resolveAccountNumber({\n      account_number: bankDetails.account_number,\n      bank_code: bankDetails.bank_code,\n    });\n\n    if (!accountDetails.status) {\n      throw new BadRequestException(`Invalid bank account: ${accountDetails.message}`);\n    }\n\n    // Create transfer recipient\n    const recipientResponse = await this.paystackService.createTransferRecipient({\n      type: 'nuban',\n      name: accountDetails.data?.account_name || landlord.firstName + ' ' + landlord.lastName,\n      account_number: bankDetails.account_number,\n      bank_code: bankDetails.bank_code,\n      metadata: {\n        landlordId: landlord.id,\n        email: landlord.email,\n      },\n    });\n\n    if (!recipientResponse.status) {\n      throw new BadRequestException(`Failed to create recipient: ${recipientResponse.message}`);\n    }\n\n    // Save recipient code to landlord\n    await this.db\n      .update(users)\n      .set({\n        paystackRecipientCode: recipientResponse.data?.recipient_code,\n        bankAccountName: accountDetails.data?.account_name,\n        bankAccountNumber: bankDetails.account_number,\n        bankCode: bankDetails.bank_code,\n        updatedAt: new Date(),\n      })\n      .where(eq(users.id, landlordId));\n\n    this.logger.log(`‚úÖ Bank account set up for landlord ${landlordId}`);\n\n    return {\n      success: true,\n      message: 'Bank account set up successfully',\n      recipient_code: recipientResponse.data?.recipient_code,\n    };\n  }\n\n  /**\n   * GET LANDLORD BANK ACCOUNTS\n   * \n   * Returns landlord's saved bank accounts.\n   */\n  async getLandlordBankAccounts(landlordId: string): Promise<any[]> {\n    this.logger.log(`üí≥ Fetching bank accounts for landlord ${landlordId}`);\n\n    // Get landlord\n    const [landlord] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, landlordId))\n      .limit(1);\n\n    if (!landlord) {\n      throw new NotFoundException(`Landlord ${landlordId} not found`);\n    }\n\n    // Check if landlord has bank account setup\n    if (!landlord.bankAccountNumber || !landlord.bankCode) {\n      this.logger.log(`‚ÑπÔ∏è No bank account found for landlord ${landlordId}`);\n      return [];\n    }\n\n    // Get bank name from Paystack\n    const banksResponse = await this.paystackService.listBanks('nigeria');\n    const bank = banksResponse.data?.find(b => b.code === landlord.bankCode);\n\n    const accounts = [{\n      accountName: landlord.bankAccountName,\n      accountNumber: landlord.bankAccountNumber,\n      bankCode: landlord.bankCode,\n      bankName: bank?.name || 'Unknown Bank',\n      recipientCode: landlord.paystackRecipientCode,\n    }];\n\n    this.logger.log(`‚úÖ Found ${accounts.length} bank account(s) for landlord ${landlordId}`);\n\n    return accounts;\n  }\n\n  // ==========================================\n  // WALLET MANAGEMENT METHODS\n  // ==========================================\n\n  /**\n   * GET WALLET BALANCE\n   * \n   * Returns landlord's current wallet balance.\n   */\n  async getWalletBalance(landlordId: string) {\n    return this.walletService.getBalance(landlordId);\n  }\n\n  /**\n   * GET LANDLORD PAYMENT STATS\n   * \n   * Returns comprehensive payment statistics for landlord dashboard.\n   */\n  async getLandlordPaymentStats(landlordId: string) {\n    try {\n      this.logger.log(`üîç Getting payment stats for landlord: ${landlordId}`);\n\n      // Get wallet balance\n      const walletBalance = await this.walletService.getBalance(landlordId);\n      this.logger.log(`üí∞ Wallet balance: ${walletBalance.availableBalance}`);\n\n      // Get recent transactions\n      const transactions = await this.walletService.getTransactions(landlordId, { limit: 10 });\n      this.logger.log(`üìä Transactions count: ${transactions?.length || 0}`);\n\n      // Get payments directly for this landlord\n      const landlordPayments = await this.db\n        .select()\n        .from(payments)\n        .where(eq(payments.landlordId, landlordId));\n      this.logger.log(`üí≥ Payments count: ${landlordPayments.length}`);\n\n      // Get contracts for upcoming/pending calculations\n      const contracts = await this.db\n        .select()\n        .from(tenantRentContracts)\n        .where(eq(tenantRentContracts.landlordId, landlordId));\n      this.logger.log(`üìã Contracts count: ${contracts.length}`);\n\n      // Calculate stats\n      const totalRentCollected = landlordPayments\n        .filter(p => p.status === 'paid')\n        .reduce((sum, p) => sum + parseFloat(p.amountPaid || '0'), 0);\n\n      const now = new Date();\n      const nextWeek = new Date();\n      nextWeek.setDate(now.getDate() + 7);\n\n      const upcomingPayments = contracts\n        .filter(c => {\n          if (!c.nextPaymentDue) return false;\n          const dueDate = new Date(c.nextPaymentDue);\n          return dueDate >= now && dueDate <= nextWeek;\n        }).length;\n\n      const pendingPayments = contracts\n        .filter(c => {\n          if (!c.nextPaymentDue) return false;\n          const dueDate = new Date(c.nextPaymentDue);\n          return dueDate < now;\n        })\n        .reduce((sum, c) => sum + parseFloat(c.monthlyAmount || '0'), 0);\n\n      // Format recent transactions\n      const recentTransactions = transactions?.slice(0, 5).map(t => ({\n        type: t.type === 'credit' ? 'credit' : 'debit',\n        description: t.description,\n        amount: typeof t.amount === 'string' ? parseFloat(t.amount) : t.amount,\n        date: t.createdAt,\n      })) || [];\n\n      const result = {\n        walletBalance: walletBalance.availableBalance || 0,\n        totalRentCollected,\n        upcomingPayments,\n        pendingPayments,\n        recentTransactions,\n      };\n\n      this.logger.log(`‚úÖ Payment stats result:`, result);\n      return result;\n    } catch (error) {\n      this.logger.error(`‚ùå Error getting landlord payment stats: ${error.message}`);\n      return {\n        walletBalance: 0,\n        totalRentCollected: 0,\n        upcomingPayments: 0,\n        pendingPayments: 0,\n        recentTransactions: [],\n      };\n    }\n  }\n\n  /**\n   * GET WALLET TRANSACTIONS\n   * \n   * Returns landlord's wallet transaction history.\n   */\n  async getWalletTransactions(landlordId: string, options?: { limit?: number; offset?: number }) {\n    return this.walletService.getTransactions(landlordId, options);\n  }\n\n  /**\n   * PROCESS WITHDRAWAL\n   * \n   * Process landlord withdrawal request.\n   * Debits wallet and initiates Paystack transfer.\n   */\n  async processWithdrawal(\n    landlordId: string,\n    amount: number,\n    reason?: string\n  ): Promise<{\n    success: boolean;\n    message: string;\n    transactionId: string;\n    transferCode?: string;\n  }> {\n    this.logger.log(`üí∏ Processing withdrawal: ‚Ç¶${amount} for landlord ${landlordId}`);\n\n    // Get landlord details\n    const [landlord] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, landlordId))\n      .limit(1);\n\n    if (!landlord) {\n      throw new NotFoundException('Landlord not found');\n    }\n\n    // Check if bank account is set up\n    if (!landlord.paystackRecipientCode) {\n      throw new BadRequestException(\n        'Please set up your bank account before requesting withdrawal'\n      );\n    }\n\n    // Get current balance\n    const balance = await this.walletService.getBalance(landlordId);\n\n    // Check sufficient balance\n    if (balance.availableBalance < amount) {\n      throw new BadRequestException(\n        `Insufficient balance. Available: ‚Ç¶${balance.availableBalance}, Requested: ‚Ç¶${amount}`\n      );\n    }\n\n    // Minimum withdrawal amount\n    const MIN_WITHDRAWAL = 1000; // ‚Ç¶1,000\n    if (amount < MIN_WITHDRAWAL) {\n      throw new BadRequestException(`Minimum withdrawal amount is ‚Ç¶${MIN_WITHDRAWAL}`);\n    }\n\n    try {\n      // Debit wallet first\n      const transaction = await this.walletService.debit(landlordId, amount, {\n        type: 'withdrawal',\n        description: reason || 'Withdrawal to bank account',\n      });\n\n      // Initiate Paystack transfer\n      const transferResponse = await this.paystackService.initiateTransfer({\n        amount: amount,\n        recipient: landlord.paystackRecipientCode,\n        reason: reason || 'Wallet withdrawal',\n        metadata: {\n          landlordId: landlord.id,\n          transactionId: transaction.id,\n          type: 'wallet_withdrawal',\n        },\n      });\n\n      if (!transferResponse.status) {\n        // Transfer failed - reverse the debit\n        this.logger.error(`‚ùå Transfer failed, reversing debit: ${transferResponse.message}`);\n        \n        await this.walletService.credit(landlordId, amount, {\n          type: 'refund',\n          description: `Refund for failed withdrawal: ${transferResponse.message}`,\n        });\n\n        throw new BadRequestException(`Withdrawal failed: ${transferResponse.message}`);\n      }\n\n      this.logger.log(`‚úÖ Withdrawal processed: ${transaction.id}`);\n      this.logger.log(`   Transfer code: ${transferResponse.data?.transfer_code}`);\n\n      return {\n        success: true,\n        message: 'Withdrawal processed successfully. Funds will be transferred to your bank account.',\n        transactionId: transaction.id,\n        transferCode: transferResponse.data?.transfer_code,\n      };\n    } catch (error) {\n      this.logger.error(`‚ùå Withdrawal error: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * CHECK FOR PENDING PAYMENT\n   * \n   * Check if tenant has any pending payments to prevent duplicates\n   * Auto-cancel payments older than 1 hour\n   */\n  async checkPendingPayment(tenantId: string): Promise<boolean> {\n    try {\n      const [pendingPayment] = await this.db\n        .select()\n        .from(payments)\n        .where(\n          and(\n            eq(payments.tenantId, tenantId),\n            eq(payments.status, 'pending'),\n            eq(payments.paymentGateway, 'paystack')\n          )\n        )\n        .limit(1);\n\n      if (!pendingPayment) {\n        return false;\n      }\n\n      // Auto-cancel if older than 5 minutes (300 seconds)\n      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n      if (pendingPayment.createdAt && new Date(pendingPayment.createdAt) < fiveMinutesAgo) {\n        this.logger.log(`üóëÔ∏è Auto-canceling expired pending payment: ${pendingPayment.id}`);\n        await this.db\n          .update(payments)\n          .set({ \n            status: 'overdue',\n            updatedAt: new Date(),\n          })\n          .where(eq(payments.id, pendingPayment.id));\n        return false; // Allow new payment\n      }\n\n      return true; // Has recent pending payment\n    } catch (error) {\n      this.logger.error(`Error checking pending payment: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * CREATE PENDING PAYMENT RECORD\n   * \n   * Create a payment record when payment is initialized\n   */\n  async createPendingPaymentRecord(data: {\n    tenantId: string;\n    amount: number;\n    paystackReference: string;\n    description?: string;\n    metadata?: any;\n  }) {\n    try {\n      // Get tenant's property and unit info from invitation\n      const [invitation] = await this.db\n        .select()\n        .from(schema.tenantInvitations)\n        .where(\n          and(\n            eq(schema.tenantInvitations.tenantId, data.tenantId),\n            eq(schema.tenantInvitations.status, 'accepted')\n          )\n        )\n        .limit(1);\n\n      if (!invitation) {\n        throw new NotFoundException('Tenant invitation not found');\n      }\n\n      // Create payment record\n      const [payment] = await this.db\n        .insert(payments)\n        .values({\n          tenantId: data.tenantId,\n          landlordId: invitation.landlordId,\n          propertyId: invitation.propertyId,\n          unitId: invitation.unitId,\n          tenantInvitationId: invitation.id,\n          amount: data.amount.toString(),\n          amountPaid: '0',\n          dueDate: new Date(),\n          paymentType: 'rent',\n          paymentMethod: 'online',\n          status: 'pending',\n          description: data.description || 'Rent payment',\n          paystackReference: data.paystackReference,\n          paystackStatus: 'pending',\n          paymentGateway: 'paystack',\n        })\n        .returning();\n\n      this.logger.log(`üíæ Payment record created: ${payment.id} (${data.paystackReference})`);\n\n      return payment;\n    } catch (error) {\n      this.logger.error(`Error creating payment record: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * UPDATE PAYMENT STATUS\n   * \n   * Update payment record based on Paystack verification\n   */\n  async updatePaymentStatus(\n    paystackReference: string,\n    paystackStatus: string,\n    paystackData: any\n  ) {\n    try {\n      // Find payment by Paystack reference\n      const [payment] = await this.db\n        .select()\n        .from(payments)\n        .where(eq(payments.paystackReference, paystackReference))\n        .limit(1);\n\n      if (!payment) {\n        this.logger.warn(`‚ö†Ô∏è Payment not found for reference: ${paystackReference}`);\n        return null;\n      }\n\n      // IDEMPOTENCY CHECK: Don't process if already paid\n      if (payment.status === 'paid') {\n        this.logger.warn(`‚ö†Ô∏è Payment already processed: ${paystackReference}`);\n        return payment;\n      }\n\n      // Map Paystack status to our payment status\n      let newStatus: 'pending' | 'paid' | 'overdue' | 'partial' = 'pending';\n      let paidDate: Date | null = null;\n      let amountPaid = '0';\n\n      if (paystackStatus === 'success') {\n        // AMOUNT VALIDATION: Verify Paystack charged the correct amount\n        const expectedAmountInNaira = parseFloat(payment.amount);\n        \n        // IMPORTANT: Paystack's verification API returns amount in Naira (already divided by 100)\n        // NOT in kobo like the initialization API expects\n        const paystackAmountInNaira = parseFloat(paystackData.amount);\n        \n        // Allow 1% tolerance for rounding errors\n        const tolerance = expectedAmountInNaira * 0.01;\n        const difference = Math.abs(expectedAmountInNaira - paystackAmountInNaira);\n        \n        this.logger.log(`üí∞ Amount validation:`);\n        this.logger.log(`   Expected: ‚Ç¶${expectedAmountInNaira}`);\n        this.logger.log(`   Paystack: ‚Ç¶${paystackAmountInNaira}`);\n        this.logger.log(`   Difference: ‚Ç¶${difference} (tolerance: ‚Ç¶${tolerance})`);\n        \n        if (difference > tolerance) {\n          this.logger.error(\n            `‚ùå AMOUNT MISMATCH! Expected: ‚Ç¶${expectedAmountInNaira}, ` +\n            `Got: ‚Ç¶${paystackAmountInNaira}`\n          );\n          throw new Error(\n            `Payment amount mismatch. Expected ‚Ç¶${expectedAmountInNaira}, but Paystack processed ‚Ç¶${paystackAmountInNaira}`\n          );\n        }\n\n        newStatus = 'paid';\n        paidDate = new Date(paystackData.paid_at || new Date());\n        // Use the original payment amount from our DB (source of truth)\n        amountPaid = payment.amount;\n        \n        this.logger.log(`‚úÖ Payment validated and marked as paid: ‚Ç¶${amountPaid}`);\n      } else if (paystackStatus === 'failed') {\n        newStatus = 'pending'; // Keep as pending so they can retry\n      }\n\n      // Update payment record\n      const [updatedPayment] = await this.db\n        .update(payments)\n        .set({\n          status: newStatus,\n          paystackStatus: paystackStatus,\n          paidDate: paidDate,\n          amountPaid: amountPaid,\n          receiptNumber: paystackData.reference,\n          updatedAt: new Date(),\n        })\n        .where(eq(payments.id, payment.id))\n        .returning();\n\n      this.logger.log(`‚úÖ Payment updated: ${payment.id} -> ${newStatus}`);\n\n      // If payment is successful, credit landlord wallet\n      if (newStatus === 'paid') {\n        await this.walletService.credit(\n          payment.landlordId,\n          parseFloat(amountPaid),\n          {\n            type: 'rent_payment',\n            paymentId: payment.id,\n            reference: paystackReference,\n            description: `Rent payment from tenant - ${paystackReference}`,\n          }\n        );\n        this.logger.log(`üí∞ Landlord wallet credited: ${payment.landlordId}`);\n      }\n\n      return updatedPayment;\n    } catch (error) {\n      this.logger.error(`Error updating payment status: ${error.message}`);\n      throw error;\n    }\n  }\n}\n\n"],"names":["PaymentProcessorService","processPayment","dto","logger","log","contractId","contract","db","select","from","tenantRentContracts","where","eq","id","limit","BadRequestException","status","expectedAmount","parseFloat","monthlyAmount","Math","abs","amount","payoutMessage","transactionId","landlordPayoutType","processImmediatePayout","landlordId","paymentMethod","reference","addToEscrow","createPaymentRecord","nextPaymentDue","addMonths","updateNextPaymentDue","toDateString","success","payoutType","message","error","stack","transaction","walletService","credit","type","description","existingEscrow","landlordEscrowBalances","and","isReleased","newTotal","totalEscrowed","newMonthsAccumulated","monthsAccumulated","update","set","toFixed","updatedAt","Date","expectedReleaseDate","BUSINESS_RULES","ESCROW","AUTO_RELEASE_MONTHS","escrowData","insert","values","paymentData","tenantId","propertyId","unitId","amountPaid","dueDate","paidDate","paymentType","receiptNumber","startOfMonth","toLocaleDateString","month","year","notes","payments","getPaymentHistory","orderBy","sql","getUpcomingPayments","contracts","map","getPaymentStatus","today","setHours","due","diffDays","floor","getTime","PAYMENT_GRACE_DAYS","initializePayment","tenantEmail","NotFoundException","paystackService","generateReference","paystackResponse","initializeTransaction","email","callback_url","process","env","FRONTEND_URL","metadata","data","authorization_url","completePayment","verification","verifyTransaction","gateway_response","authorization","reusable","savePaymentAuthorization","channel","chargeRecurringPayment","tenant","users","paystackAuthorizationCode","chargeResponse","chargeAuthorization","authorization_code","paystackCardLast4","last4","paystackCardBrand","brand","paystackCardBank","bank","processLandlordPayout","reason","landlord","paystackRecipientCode","transferResponse","initiateTransfer","recipient","transfer_code","setupLandlordBankAccount","bankDetails","accountDetails","resolveAccountNumber","account_number","bank_code","recipientResponse","createTransferRecipient","name","account_name","firstName","lastName","recipient_code","bankAccountName","bankAccountNumber","bankCode","getLandlordBankAccounts","banksResponse","listBanks","find","b","code","accounts","accountName","accountNumber","bankName","recipientCode","length","getWalletBalance","getBalance","getLandlordPaymentStats","walletBalance","availableBalance","transactions","getTransactions","landlordPayments","totalRentCollected","filter","p","reduce","sum","now","nextWeek","setDate","getDate","upcomingPayments","c","pendingPayments","recentTransactions","slice","t","date","createdAt","result","getWalletTransactions","options","processWithdrawal","balance","MIN_WITHDRAWAL","debit","transferCode","checkPendingPayment","pendingPayment","paymentGateway","fiveMinutesAgo","createPendingPaymentRecord","invitation","schema","tenantInvitations","payment","tenantInvitationId","toString","paystackReference","paystackStatus","returning","updatePaymentStatus","paystackData","warn","newStatus","expectedAmountInNaira","paystackAmountInNaira","tolerance","difference","Error","paid_at","updatedPayment","paymentId","Logger"],"mappings":"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"}