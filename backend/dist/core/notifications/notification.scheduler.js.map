{"version":3,"sources":["../../../src/core/notifications/notification.scheduler.ts"],"sourcesContent":["import { Injectable, Inject, Logger } from '@nestjs/common';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { PostgresJsDatabase } from 'drizzle-orm/postgres-js';\nimport { eq, and, lte, gte, sql } from 'drizzle-orm';\nimport { DATABASE_CONNECTION } from '../../database/database.module';\nimport * as schema from '../../database/schema';\nimport { tenantRentContracts } from '../../database/schema/tenant-rent-contracts';\nimport { users } from '../../database/schema';\nimport { NotificationSenderService } from './notification-sender.service';\nimport { BUSINESS_RULES } from '../../shared/constants/business-rules.constant';\nimport { startOfDay, addDays, subDays, differenceInDays } from '../../shared/utils/date.utils';\n\n/**\n * NOTIFICATION SCHEDULER SERVICE\n * \n * Automated notification system using cron jobs.\n * Runs daily to check payment statuses and send appropriate notifications.\n * \n * Schedule:\n * - 9:00 AM: Send payment reminders (early reminders, due today)\n * - 10:00 AM: Check overdue payments and send escalating reminders\n * - 11:00 AM: Send contract expiry warnings\n * \n * Key responsibilities:\n * 1. Identify contracts with upcoming payments\n * 2. Identify overdue payments\n * 3. Send multi-channel notifications\n * 4. Track notification status\n * 5. Handle escalation for repeated overdue payments\n */\n@Injectable()\nexport class NotificationScheduler {\n  private readonly logger = new Logger(NotificationScheduler.name);\n\n  constructor(\n    @Inject(DATABASE_CONNECTION)\n    private readonly db: PostgresJsDatabase<typeof schema>,\n    private readonly notificationSender: NotificationSenderService,\n  ) {}\n\n  /**\n   * DAILY CRON: SEND PAYMENT REMINDERS\n   * \n   * Runs every day at 9:00 AM\n   * \n   * Sends reminders for:\n   * 1. Payments due in 3 days (early reminder)\n   * 2. Payments due today\n   * \n   * Business rule: Early reminder 3 days before due date\n   */\n  @Cron('0 9 * * *')\n  async sendPaymentReminders(): Promise<void> {\n    this.logger.log('üîî Starting daily payment reminder job...');\n\n    try {\n      const today = startOfDay(new Date());\n\n      // 1. Get contracts with payment due in 3 days (early reminder)\n      const earlyReminderDate = addDays(today, BUSINESS_RULES.PAYMENT_REMINDERS.EARLY_REMINDER_DAYS);\n      const earlyReminderContracts = await this.getContractsDueOn(earlyReminderDate);\n\n      this.logger.log(`Found ${earlyReminderContracts.length} contracts due in 3 days`);\n\n      for (const contract of earlyReminderContracts) {\n        await this.sendReminderForContract(contract, 3);\n      }\n\n      // 2. Get contracts with payment due TODAY\n      if (BUSINESS_RULES.PAYMENT_REMINDERS.DUE_TODAY_REMINDER) {\n        const dueTodayContracts = await this.getContractsDueOn(today);\n\n        this.logger.log(`Found ${dueTodayContracts.length} contracts due today`);\n\n        for (const contract of dueTodayContracts) {\n          await this.sendReminderForContract(contract, 0);\n        }\n      }\n\n      this.logger.log('‚úÖ Payment reminder job completed successfully');\n    } catch (error) {\n      this.logger.error(`‚ùå Error in payment reminder job: ${error.message}`, error.stack);\n    }\n  }\n\n  /**\n   * DAILY CRON: CHECK OVERDUE PAYMENTS\n   * \n   * Runs every day at 10:00 AM\n   * \n   * Checks for overdue payments and sends escalating reminders.\n   * Sends reminders at: 1, 3, 7, 14 days overdue\n   * \n   * After grace period (3 days), marks as overdue and sends:\n   * - Push notification\n   * - Email\n   * - SMS (critical alert)\n   */\n  @Cron('0 10 * * *')\n  async checkOverduePayments(): Promise<void> {\n    this.logger.log('‚ö†Ô∏è Starting overdue payment check...');\n\n    try {\n      const today = startOfDay(new Date());\n      const gracePeriodEnd = subDays(today, BUSINESS_RULES.PAYMENT_GRACE_DAYS);\n\n      // Get all contracts with payment overdue (past grace period)\n      const overdueContracts = await this.db\n        .select()\n        .from(tenantRentContracts)\n        .where(\n          and(\n            eq(tenantRentContracts.status, 'active'),\n            lte(tenantRentContracts.nextPaymentDue, gracePeriodEnd)\n          )\n        );\n\n      this.logger.log(`Found ${overdueContracts.length} overdue contracts`);\n\n      for (const contract of overdueContracts) {\n        const daysOverdue = Math.abs(differenceInDays(today, contract.nextPaymentDue));\n\n        // Check if we should send reminder based on escalation schedule\n        if (this.shouldSendOverdueReminder(daysOverdue)) {\n          this.logger.warn(`Contract ${contract.id}: ${daysOverdue} days overdue - sending reminder`);\n          await this.sendReminderForContract(contract, -daysOverdue);\n        }\n      }\n\n      this.logger.log('‚úÖ Overdue payment check completed');\n    } catch (error) {\n      this.logger.error(`‚ùå Error in overdue payment check: ${error.message}`, error.stack);\n    }\n  }\n\n  /**\n   * WEEKLY CRON: CHECK EXPIRING CONTRACTS\n   * \n   * Runs every Sunday at 11:00 AM\n   * \n   * Warns landlords and tenants about contracts expiring soon (within 30 days).\n   */\n  @Cron('0 11 * * 0')\n  async checkExpiringContracts(): Promise<void> {\n    this.logger.log('üìÖ Checking for expiring contracts...');\n\n    try {\n      const today = startOfDay(new Date());\n      const thirtyDaysFromNow = addDays(today, 30);\n\n      // Get contracts expiring in next 30 days\n      const expiringContracts = await this.db\n        .select()\n        .from(tenantRentContracts)\n        .where(\n          and(\n            eq(tenantRentContracts.status, 'active'),\n            lte(tenantRentContracts.expiryDate, thirtyDaysFromNow),\n            gte(tenantRentContracts.expiryDate, today)\n          )\n        );\n\n      this.logger.log(`Found ${expiringContracts.length} contracts expiring soon`);\n\n      for (const contract of expiringContracts) {\n        const daysUntilExpiry = differenceInDays(contract.expiryDate, today);\n        this.logger.log(`Contract ${contract.id} expires in ${daysUntilExpiry} days`);\n\n        // TODO: Send contract expiry notifications to both tenant and landlord\n        // await this.notificationSender.sendContractExpiryWarning(...)\n      }\n\n      this.logger.log('‚úÖ Expiring contract check completed');\n    } catch (error) {\n      this.logger.error(`‚ùå Error checking expiring contracts: ${error.message}`, error.stack);\n    }\n  }\n\n  /**\n   * GET CONTRACTS DUE ON SPECIFIC DATE\n   * \n   * Helper to find contracts with payment due on a specific date.\n   * \n   * @param date - Due date to check\n   * @returns Contracts with payment due\n   */\n  private async getContractsDueOn(date: Date): Promise<any[]> {\n    const startOfDate = startOfDay(date);\n    const endOfDate = new Date(startOfDate);\n    endOfDate.setHours(23, 59, 59, 999);\n\n    return this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(\n        and(\n          eq(tenantRentContracts.status, 'active'),\n          gte(tenantRentContracts.nextPaymentDue, startOfDate),\n          lte(tenantRentContracts.nextPaymentDue, endOfDate)\n        )\n      );\n  }\n\n  /**\n   * SEND REMINDER FOR CONTRACT\n   * \n   * Sends payment reminder notification to tenant.\n   * Fetches tenant details and sends multi-channel notification.\n   * \n   * @param contract - Rent contract\n   * @param daysUntilDue - Days until due (negative if overdue)\n   */\n  private async sendReminderForContract(\n    contract: typeof tenantRentContracts.$inferSelect,\n    daysUntilDue: number\n  ): Promise<void> {\n    try {\n      // Get tenant details\n      const [tenant] = await this.db\n        .select()\n        .from(users)\n        .where(eq(users.id, contract.tenantId))\n        .limit(1);\n\n      if (!tenant) {\n        this.logger.warn(`Tenant ${contract.tenantId} not found for contract ${contract.id}`);\n        return;\n      }\n\n      // Get tenant's push token (if exists)\n      // TODO: Add pushToken field to users table\n      const pushToken = (tenant as any).pushToken || null;\n\n      // Send notification\n      await this.notificationSender.sendPaymentReminder(\n        tenant.id,\n        tenant.email,\n        parseFloat(contract.monthlyAmount),\n        contract.nextPaymentDue,\n        daysUntilDue,\n        tenant.phoneNumber || undefined,\n        pushToken\n      );\n\n      this.logger.log(`‚úÖ Reminder sent to tenant ${tenant.id} (${tenant.email})`);\n    } catch (error) {\n      this.logger.error(`‚ùå Failed to send reminder for contract ${contract.id}: ${error.message}`, error.stack);\n    }\n  }\n\n  /**\n   * SHOULD SEND OVERDUE REMINDER\n   * \n   * Determines if we should send reminder based on days overdue.\n   * Only sends on specific days to avoid spam (1, 3, 7, 14 days overdue).\n   * \n   * @param daysOverdue - Number of days payment is overdue\n   * @returns True if should send reminder\n   */\n  private shouldSendOverdueReminder(daysOverdue: number): boolean {\n    return (BUSINESS_RULES.PAYMENT_REMINDERS.OVERDUE_REMINDER_DAYS as readonly number[]).includes(daysOverdue);\n  }\n\n  /**\n   * MANUAL TRIGGER: Send reminder for specific contract\n   * \n   * Allows manual triggering of reminders (useful for testing or admin actions).\n   * \n   * @param contractId - Contract ID\n   */\n  async sendManualReminder(contractId: string): Promise<void> {\n    this.logger.log(`üì¨ Manually sending reminder for contract ${contractId}`);\n\n    const [contract] = await this.db\n      .select()\n      .from(tenantRentContracts)\n      .where(eq(tenantRentContracts.id, contractId))\n      .limit(1);\n\n    if (!contract) {\n      throw new Error(`Contract ${contractId} not found`);\n    }\n\n    const today = startOfDay(new Date());\n    const daysUntilDue = differenceInDays(contract.nextPaymentDue, today);\n\n    await this.sendReminderForContract(contract, daysUntilDue);\n\n    this.logger.log(`‚úÖ Manual reminder sent for contract ${contractId}`);\n  }\n}\n\n"],"names":["NotificationScheduler","sendPaymentReminders","logger","log","today","startOfDay","Date","earlyReminderDate","addDays","BUSINESS_RULES","PAYMENT_REMINDERS","EARLY_REMINDER_DAYS","earlyReminderContracts","getContractsDueOn","length","contract","sendReminderForContract","DUE_TODAY_REMINDER","dueTodayContracts","error","message","stack","checkOverduePayments","gracePeriodEnd","subDays","PAYMENT_GRACE_DAYS","overdueContracts","db","select","from","tenantRentContracts","where","and","eq","status","lte","nextPaymentDue","daysOverdue","Math","abs","differenceInDays","shouldSendOverdueReminder","warn","id","checkExpiringContracts","thirtyDaysFromNow","expiringContracts","expiryDate","gte","daysUntilExpiry","date","startOfDate","endOfDate","setHours","daysUntilDue","tenant","users","tenantId","limit","pushToken","notificationSender","sendPaymentReminder","email","parseFloat","monthlyAmount","phoneNumber","undefined","OVERDUE_REMINDER_DAYS","includes","sendManualReminder","contractId","Error","Logger","name"],"mappings":"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"}