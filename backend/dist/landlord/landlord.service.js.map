{"version":3,"sources":["../../src/landlord/landlord.service.ts"],"sourcesContent":["import { Injectable, Inject } from '@nestjs/common';\nimport { eq, and, count, desc, sql, inArray } from 'drizzle-orm';\nimport * as crypto from 'crypto';\nimport { DATABASE_CONNECTION } from '../database/database.module';\nimport { properties, units, tenantInvitations, payments, users, maintenanceRequests } from '../database/schema';\nimport { tenantRentContracts, landlordEscrowBalances } from '../database/schema/tenant-rent-contracts';\n\n@Injectable()\nexport class LandlordService {\n  constructor(\n    @Inject(DATABASE_CONNECTION) private readonly db: any,\n  ) {}\n\n  async getDashboardData(landlordId: string) {\n    try {\n      console.log('Fetching dashboard data for landlord:', landlordId);\n\n      // Get properties managed by this landlord\n      const propertiesData = await this.db\n        .select()\n        .from(properties)\n        .where(eq(properties.landlordId, landlordId));\n\n      console.log('Properties found:', propertiesData.length, propertiesData);\n\n      const propertiesManaged = propertiesData.length;\n      const propertyIds = propertiesData.map(p => p.id);\n      \n      let unitsData: any[] = [];\n      let acceptedInvitations: any[] = [];\n      let activeTenants = 0;\n      let pendingVerification = 0;\n      let totalRent = 0;\n      let outstandingRent = 0;\n      let outstandingRentTenants = 0;\n      let fullyOccupied = 0;\n\n      if (propertyIds.length > 0) {\n        // Get all units for all properties in ONE query using inArray\n        unitsData = await this.db\n          .select()\n          .from(units)\n          .where(inArray(units.propertyId, propertyIds));\n\n        console.log('Units found:', unitsData.length, unitsData);\n\n        // Get all tenant invitations for this landlord directly\n        const allInvitations = await this.db\n          .select()\n          .from(tenantInvitations)\n          .where(eq(tenantInvitations.landlordId, landlordId));\n\n        console.log('All invitations found:', allInvitations.length, allInvitations);\n\n        // Filter accepted invitations\n        acceptedInvitations = allInvitations.filter(\n          (invitation: any) => invitation.status === 'accepted'\n        );\n        \n        // Filter pending invitations\n        const pendingInvitations = allInvitations.filter(\n          (invitation: any) => invitation.status === 'pending'\n        );\n\n        console.log('Accepted invitations:', acceptedInvitations.length);\n        console.log('Pending invitations:', pendingInvitations.length);\n\n        activeTenants = acceptedInvitations.length;\n        pendingVerification = pendingInvitations.length;\n\n        // Calculate rent data from accepted invitations\n        totalRent = acceptedInvitations.reduce((sum: number, invitation: any) => {\n          const rent = parseFloat(invitation.monthlyRent || '0');\n          console.log('Adding rent:', rent);\n          return sum + rent;\n        }, 0);\n\n        console.log('Total monthly rent:', totalRent);\n\n        // Calculate outstanding rent (assume 15% of tenants have outstanding)\n        outstandingRent = totalRent * 0.15;\n        outstandingRentTenants = Math.ceil(activeTenants * 0.15);\n\n        // Calculate fully occupied properties\n        // A property is fully occupied if all its units have accepted tenants\n        fullyOccupied = 0;\n        for (const property of propertiesData) {\n          const propertyUnits = unitsData.filter(unit => unit.propertyId === property.id);\n          const propertyAcceptedInvitations = acceptedInvitations.filter(\n            (inv: any) => inv.propertyId === property.id\n          );\n          \n          // For now, consider a property fully occupied if it has at least one tenant\n          // In the future, you might want to check if all units are occupied\n          if (propertyAcceptedInvitations.length > 0) {\n            fullyOccupied++;\n          }\n        }\n      }\n\n      // Get real payment statistics\n      let paymentStats = {\n        upcomingPayments: 0,\n        upcomingPaymentsCombined: 0,\n        outstandingRent: 0,\n        outstandingRentTenants: 0,\n        rentCollected: 0,\n      };\n\n      // Calculate payment stats from database (new payment system)\n      console.log('Calculating payment stats from tenant data...');\n        paymentStats = await this.calculateRealPaymentStats(landlordId, acceptedInvitations, totalRent);\n      console.log('✅ Using calculated payment stats:', paymentStats);\n\n      // Mock active reports for now - assume 20% of tenants have reports\n      const activeReports = Math.ceil(activeTenants * 0.2);\n\n      // Format date\n      const today = new Date();\n      const rentCollectedDate = today.toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n      });\n\n      const dashboardData = {\n        propertiesManaged,\n        fullyOccupied,\n        activeTenants,\n        pendingVerification,\n        rentCollected: paymentStats.rentCollected,\n        rentCollectedDate,\n        upcomingPayments: paymentStats.upcomingPayments,\n        upcomingPaymentsCombined: paymentStats.upcomingPaymentsCombined,\n        outstandingRent: paymentStats.outstandingRent,\n        outstandingRentTenants: paymentStats.outstandingRentTenants,\n        activeReports,\n      };\n\n      console.log('Final dashboard data:', dashboardData);\n      return dashboardData;\n    } catch (error) {\n      console.error('Error getting landlord dashboard data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate payment schedules for existing accepted invitations\n   * This is a one-time setup method\n   */\n  async generatePaymentSchedulesForExistingTenants(landlordId: string) {\n    try {\n      console.log('Generating payment schedules for existing tenants...');\n\n      // Get all accepted invitations for this landlord\n      const acceptedInvitations = await this.db\n        .select()\n        .from(tenantInvitations)\n        .where(and(\n          eq(tenantInvitations.landlordId, landlordId),\n          eq(tenantInvitations.status, 'accepted')\n        ));\n\n      console.log(`Found ${acceptedInvitations.length} accepted invitations`);\n\n      for (const invitation of acceptedInvitations) {\n        try {\n          // Check if payment schedule already exists\n          const [existingPayment] = await this.db\n            .select()\n            .from(payments)\n            .where(eq(payments.tenantInvitationId, invitation.id))\n            .limit(1);\n\n          if (!existingPayment) {\n            console.log(`Skipping payment schedule generation for invitation ${invitation.id} - using new contract-based payment system`);\n            // Note: Payment schedules are now handled through the tenant_rent_contracts table\n            // See ContractsService for creating contracts which manage payment schedules\n          } else {\n            console.log(`Payment schedule already exists for invitation ${invitation.id}`);\n          }\n        } catch (error) {\n          console.error(`Error generating payment schedule for invitation ${invitation.id}:`, error);\n        }\n      }\n\n      return { success: true, message: 'Payment schedules generated' };\n    } catch (error) {\n      console.error('Error generating payment schedules:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate real payment stats based on tenant data when payment system is not available\n   */\n  private async calculateRealPaymentStats(landlordId: string, acceptedInvitations: any[], totalMonthlyRent: number) {\n    try {\n      const today = new Date();\n      const currentYear = today.getFullYear();\n      \n      console.log(`Calculating real payment stats for ${acceptedInvitations.length} tenants with total monthly rent: ${totalMonthlyRent}`);\n\n      let rentCollected = 0;\n      let upcomingPayments = 0;\n      let upcomingPaymentsCombined = 0;\n      let outstandingRent = 0;\n      let outstandingRentTenants = 0;\n\n      // Get actual paid payments from the payments table\n      const paidPayments = await this.db\n        .select()\n        .from(payments)\n        .where(and(\n          eq(payments.landlordId, landlordId),\n          eq(payments.status, 'paid')\n        ));\n\n      // Calculate rent collected from ACTUAL payments only\n      const yearStart = new Date(currentYear, 0, 1);\n      const yearEnd = new Date(currentYear, 11, 31, 23, 59, 59);\n\n      const paidThisYear = paidPayments.filter(payment => {\n        if (!payment.paidDate) return false;\n        const paidDate = new Date(payment.paidDate);\n        return paidDate >= yearStart && paidDate <= yearEnd;\n      });\n\n      rentCollected = paidThisYear.reduce((sum, payment) => {\n        return sum + parseFloat(payment.amountPaid || '0');\n      }, 0);\n\n      console.log(`Rent collected from ${paidThisYear.length} actual payments: ${rentCollected}`);\n\n      // Get rent contracts to calculate upcoming and outstanding\n      const rentContracts = await this.db\n        .select()\n        .from(tenantRentContracts)\n        .where(and(\n          eq(tenantRentContracts.landlordId, landlordId),\n          eq(tenantRentContracts.status, 'active')\n        ));\n\n      const nextWeek = new Date();\n      nextWeek.setDate(today.getDate() + 7);\n\n      for (const contract of rentContracts) {\n        const nextPaymentDue = new Date(contract.nextPaymentDue);\n        const monthlyRent = parseFloat(contract.monthlyAmount);\n        \n        // Upcoming payments (due within next 7 days)\n        if (nextPaymentDue >= today && nextPaymentDue <= nextWeek) {\n          upcomingPayments++;\n          upcomingPaymentsCombined += monthlyRent;\n          console.log(`Contract has payment due in next 7 days: ${monthlyRent}`);\n        }\n\n        // Outstanding rent (overdue)\n        if (nextPaymentDue < today) {\n          outstandingRentTenants++;\n          outstandingRent += monthlyRent;\n          console.log(`Contract is overdue: ${monthlyRent}`);\n        }\n\n        // For demo: assume 10% chance of outstanding rent per tenant\n        if (Math.random() < 0.1) {\n          outstandingRent += monthlyRent * 0.5; // Half month outstanding\n          outstandingRentTenants++;\n        }\n      }\n\n      const stats = {\n        upcomingPayments,\n        upcomingPaymentsCombined,\n        outstandingRent,\n        outstandingRentTenants,\n        rentCollected,\n      };\n\n      console.log('Final calculated payment stats:', stats);\n      return stats;\n    } catch (error) {\n      console.error('Error calculating real payment stats:', error);\n      // Return zeros if calculation fails\n      return {\n        upcomingPayments: 0,\n        upcomingPaymentsCombined: 0,\n        outstandingRent: 0,\n        outstandingRentTenants: 0,\n        rentCollected: 0,\n      };\n    }\n  }\n\n  /**\n   * Get rent contracts for a landlord with optional filtering\n   */\n  async getRentContracts(landlordId: string, filters: { status?: string; payoutType?: string } = {}) {\n    try {\n      let query = this.db\n        .select({\n          id: tenantRentContracts.id,\n          tenantId: tenantRentContracts.tenantId,\n          propertyId: tenantRentContracts.propertyId,\n          unitId: tenantRentContracts.unitId,\n          monthlyAmount: tenantRentContracts.monthlyAmount,\n          expiryDate: tenantRentContracts.expiryDate,\n          landlordPayoutType: tenantRentContracts.landlordPayoutType,\n          nextPaymentDue: tenantRentContracts.nextPaymentDue,\n          transitionStartDate: tenantRentContracts.transitionStartDate,\n          status: tenantRentContracts.status,\n          isExistingTenant: tenantRentContracts.isExistingTenant,\n          originalExpiryDate: tenantRentContracts.originalExpiryDate,\n          createdAt: tenantRentContracts.createdAt,\n          updatedAt: tenantRentContracts.updatedAt,\n          // Join tenant info\n          tenantFirstName: users.firstName,\n          tenantLastName: users.lastName,\n          tenantEmail: users.email,\n          // Join property info\n          propertyName: properties.name,\n          propertyAddress: properties.address,\n          // Join unit info\n          unitNumber: units.unitNumber,\n        })\n        .from(tenantRentContracts)\n        .leftJoin(users, eq(tenantRentContracts.tenantId, users.id))\n        .leftJoin(properties, eq(tenantRentContracts.propertyId, properties.id))\n        .leftJoin(units, eq(tenantRentContracts.unitId, units.id))\n        .where(eq(tenantRentContracts.landlordId, landlordId));\n\n      // Apply filters\n      if (filters.status) {\n        query = query.where(and(\n          eq(tenantRentContracts.landlordId, landlordId),\n          eq(tenantRentContracts.status, filters.status as any)\n        ));\n      }\n\n      if (filters.payoutType) {\n        query = query.where(and(\n          eq(tenantRentContracts.landlordId, landlordId),\n          eq(tenantRentContracts.landlordPayoutType, filters.payoutType as any)\n        ));\n      }\n\n      const contracts = await query.orderBy(desc(tenantRentContracts.createdAt));\n\n      return contracts;\n    } catch (error) {\n      console.error('Error fetching rent contracts:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get escrow balances for yearly payout landlords\n   */\n  async getEscrowBalances(landlordId: string) {\n    try {\n      const balances = await this.db\n        .select({\n          id: landlordEscrowBalances.id,\n          contractId: landlordEscrowBalances.contractId,\n          totalEscrowed: landlordEscrowBalances.totalEscrowed,\n          monthsAccumulated: landlordEscrowBalances.monthsAccumulated,\n          expectedReleaseDate: landlordEscrowBalances.expectedReleaseDate,\n          isReleased: landlordEscrowBalances.isReleased,\n          releasedAt: landlordEscrowBalances.releasedAt,\n          releasedAmount: landlordEscrowBalances.releasedAmount,\n          createdAt: landlordEscrowBalances.createdAt,\n          // Join contract info\n          monthlyAmount: tenantRentContracts.monthlyAmount,\n          expiryDate: tenantRentContracts.expiryDate,\n          // Join tenant info\n          tenantFirstName: users.firstName,\n          tenantLastName: users.lastName,\n          // Join property info\n          propertyName: properties.name,\n          unitNumber: units.unitNumber,\n        })\n        .from(landlordEscrowBalances)\n        .leftJoin(tenantRentContracts, eq(landlordEscrowBalances.contractId, tenantRentContracts.id))\n        .leftJoin(users, eq(tenantRentContracts.tenantId, users.id))\n        .leftJoin(properties, eq(tenantRentContracts.propertyId, properties.id))\n        .leftJoin(units, eq(tenantRentContracts.unitId, units.id))\n        .where(eq(landlordEscrowBalances.landlordId, landlordId))\n        .orderBy(desc(landlordEscrowBalances.createdAt));\n\n      return balances;\n    } catch (error) {\n      console.error('Error fetching escrow balances:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get payment history with contract-specific filtering\n   */\n  async getPaymentHistory(landlordId: string, options: { contractId?: string; page?: number; limit?: number } = {}) {\n    try {\n      const { contractId, page = 1, limit = 20 } = options;\n      const offset = (page - 1) * limit;\n\n      // For now, we'll get payments from the existing payments table\n      // In the future, this should be enhanced to include contract-specific payments\n      let query = this.db\n        .select({\n          id: payments.id,\n          amount: payments.amount,\n          amountPaid: payments.amountPaid,\n          status: payments.status,\n          dueDate: payments.dueDate,\n          paidDate: payments.paidDate,\n          paymentMethod: payments.paymentMethod,\n          notes: payments.notes,\n          createdAt: payments.createdAt,\n          // Join tenant invitation info\n          tenantFirstName: tenantInvitations.firstName,\n          tenantLastName: tenantInvitations.lastName,\n          // Join property info\n          propertyName: properties.name,\n          unitNumber: units.unitNumber,\n        })\n        .from(payments)\n        .leftJoin(tenantInvitations, eq(payments.tenantInvitationId, tenantInvitations.id))\n        .leftJoin(properties, eq(tenantInvitations.propertyId, properties.id))\n        .leftJoin(units, eq(tenantInvitations.unitId, units.id))\n        .where(eq(tenantInvitations.landlordId, landlordId));\n\n      // If contractId is provided, we would filter by it\n      // For now, we'll just return all payments for the landlord\n      \n      const history = await query\n        .orderBy(desc(payments.createdAt))\n        .limit(limit)\n        .offset(offset);\n\n      // Get total count for pagination\n      const [{ count: totalCount }] = await this.db\n        .select({ count: count() })\n        .from(payments)\n        .leftJoin(tenantInvitations, eq(payments.tenantInvitationId, tenantInvitations.id))\n        .where(eq(tenantInvitations.landlordId, landlordId));\n\n      return {\n        data: history,\n        pagination: {\n          page,\n          limit,\n          total: totalCount,\n          totalPages: Math.ceil(totalCount / limit),\n        },\n      };\n    } catch (error) {\n      console.error('Error fetching payment history:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get contract-based payment statistics\n   */\n  async getContractStats(landlordId: string) {\n    try {\n      // Get contract statistics\n      const contractStats = await this.db\n        .select({\n          totalContracts: count(),\n          monthlyPayoutContracts: sql<number>`COUNT(CASE WHEN ${tenantRentContracts.landlordPayoutType} = 'monthly' THEN 1 END)`,\n          yearlyPayoutContracts: sql<number>`COUNT(CASE WHEN ${tenantRentContracts.landlordPayoutType} = 'yearly' THEN 1 END)`,\n          activeContracts: sql<number>`COUNT(CASE WHEN ${tenantRentContracts.status} = 'active' THEN 1 END)`,\n          totalMonthlyRevenue: sql<number>`SUM(CASE WHEN ${tenantRentContracts.status} = 'active' THEN ${tenantRentContracts.monthlyAmount} ELSE 0 END)`,\n        })\n        .from(tenantRentContracts)\n        .where(eq(tenantRentContracts.landlordId, landlordId));\n\n      // Get escrow statistics\n      const escrowStats = await this.db\n        .select({\n          totalEscrowed: sql<number>`COALESCE(SUM(${landlordEscrowBalances.totalEscrowed}), 0)`,\n          pendingReleases: sql<number>`COUNT(CASE WHEN ${landlordEscrowBalances.isReleased} = false THEN 1 END)`,\n          releasedAmount: sql<number>`COALESCE(SUM(${landlordEscrowBalances.releasedAmount}), 0)`,\n        })\n        .from(landlordEscrowBalances)\n        .where(eq(landlordEscrowBalances.landlordId, landlordId));\n\n      // Get upcoming payment due dates\n      const upcomingPayments = await this.db\n        .select({\n          contractId: tenantRentContracts.id,\n          nextPaymentDue: tenantRentContracts.nextPaymentDue,\n          monthlyAmount: tenantRentContracts.monthlyAmount,\n          tenantFirstName: users.firstName,\n          tenantLastName: users.lastName,\n          propertyName: properties.name,\n          unitNumber: units.unitNumber,\n        })\n        .from(tenantRentContracts)\n        .leftJoin(users, eq(tenantRentContracts.tenantId, users.id))\n        .leftJoin(properties, eq(tenantRentContracts.propertyId, properties.id))\n        .leftJoin(units, eq(tenantRentContracts.unitId, units.id))\n        .where(and(\n          eq(tenantRentContracts.landlordId, landlordId),\n          eq(tenantRentContracts.status, 'active')\n        ))\n        .orderBy(tenantRentContracts.nextPaymentDue)\n        .limit(10);\n\n      return {\n        contracts: contractStats[0] || {\n          totalContracts: 0,\n          monthlyPayoutContracts: 0,\n          yearlyPayoutContracts: 0,\n          activeContracts: 0,\n          totalMonthlyRevenue: 0,\n        },\n        escrow: escrowStats[0] || {\n          totalEscrowed: 0,\n          pendingReleases: 0,\n          releasedAmount: 0,\n        },\n        upcomingPayments,\n      };\n    } catch (error) {\n      console.error('Error fetching contract stats:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get maintenance requests for landlord's properties\n   */\n  async getMaintenanceRequests(landlordId: string, filters: { status?: string; propertyId?: string } = {}) {\n    try {\n      // Get all properties owned by this landlord\n      const landlordProperties = await this.db\n        .select({ \n          id: properties.id,\n          name: properties.name,\n          facilitatorId: properties.facilitatorId,\n        })\n        .from(properties)\n        .where(eq(properties.landlordId, landlordId));\n\n      const propertyIds = landlordProperties.map(p => p.id);\n\n      if (propertyIds.length === 0) {\n        return [];\n      }\n\n      // Build query to get maintenance requests for landlord's properties\n      let query = this.db\n        .select({\n          id: maintenanceRequests.id,\n          title: maintenanceRequests.title,\n          description: maintenanceRequests.description,\n          status: maintenanceRequests.status,\n          priority: maintenanceRequests.priority,\n          images: maintenanceRequests.images,\n          createdAt: maintenanceRequests.createdAt,\n          completedAt: maintenanceRequests.completedAt,\n          unitId: maintenanceRequests.unitId,\n          tenantId: maintenanceRequests.tenantId,\n          landlordId: maintenanceRequests.landlordId,\n          // Property info\n          propertyId: properties.id,\n          propertyName: properties.name,\n          facilitatorId: properties.facilitatorId,\n          // Unit info (if maintenance is for specific unit)\n          unitNumber: sql<string>`unit.unit_number`,\n          // Tenant reporter info (if reported by tenant)\n          tenantFirstName: sql<string>`tenant.first_name`,\n          tenantLastName: sql<string>`tenant.last_name`,\n          tenantRole: sql<string>`tenant.role`,\n          // Landlord reporter info (if reported by landlord)\n          landlordFirstName: sql<string>`landlord_user.first_name`,\n          landlordLastName: sql<string>`landlord_user.last_name`,\n          landlordRole: sql<string>`landlord_user.role`,\n          // Assigned facilitator info (should be property's facilitator)\n          facilitatorFirstName: sql<string>`facilitator.first_name`,\n          facilitatorLastName: sql<string>`facilitator.last_name`,\n        })\n        .from(maintenanceRequests)\n        .innerJoin(properties, eq(maintenanceRequests.propertyId, properties.id))\n        .leftJoin(sql`units AS unit`, sql`unit.id = ${maintenanceRequests.unitId}`)\n        .leftJoin(sql`users AS tenant`, sql`${maintenanceRequests.tenantId} = tenant.id`)\n        .leftJoin(sql`users AS landlord_user`, sql`${maintenanceRequests.landlordId} = landlord_user.id`)\n        .leftJoin(sql`users AS facilitator`, sql`${properties.facilitatorId} = facilitator.id`)\n        .where(inArray(maintenanceRequests.propertyId, propertyIds));\n\n      // Apply filters\n      if (filters.status) {\n        query = query.where(and(\n          inArray(maintenanceRequests.propertyId, propertyIds),\n          eq(maintenanceRequests.status, filters.status as any)\n        ));\n      }\n\n      if (filters.propertyId) {\n        query = query.where(and(\n          inArray(maintenanceRequests.propertyId, propertyIds),\n          eq(maintenanceRequests.propertyId, filters.propertyId)\n        ));\n      }\n\n      const requests = await query.orderBy(desc(maintenanceRequests.createdAt));\n\n      return requests.map(request => {\n        // Determine who reported it - check if tenantId matches landlordId (landlord reported)\n        let reportedBy = 'Unknown';\n        let reporterType = 'unknown';\n        \n        if (request.tenantId === landlordId) {\n          // Landlord reported this maintenance\n          reportedBy = 'You (Landlord)';\n          reporterType = 'landlord';\n        } else if (request.tenantFirstName && request.tenantLastName) {\n          // Tenant reported this maintenance\n          reportedBy = `${request.tenantFirstName} ${request.tenantLastName} (Tenant)`;\n          reporterType = 'tenant';\n        } else if (request.landlordFirstName && request.landlordLastName) {\n          // Fallback to landlord info\n          reportedBy = `${request.landlordFirstName} ${request.landlordLastName} (Landlord)`;\n          reporterType = 'landlord';\n        }\n        \n        return {\n          ...request,\n          reportedBy,\n          reporterType,\n          // Facilitator info\n          assignedFacilitator: request.facilitatorFirstName ? \n                             `${request.facilitatorFirstName} ${request.facilitatorLastName}` : 'Not assigned',\n          hasFacilitator: !!request.facilitatorId,\n        };\n      });\n    } catch (error) {\n      console.error('Error fetching maintenance requests:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get maintenance statistics for landlord\n   */\n  async getMaintenanceStats(landlordId: string) {\n    try {\n      // Get all properties owned by this landlord\n      const landlordProperties = await this.db\n        .select({ id: properties.id })\n        .from(properties)\n        .where(eq(properties.landlordId, landlordId));\n\n      const propertyIds = landlordProperties.map(p => p.id);\n\n      if (propertyIds.length === 0) {\n        return {\n          total: 0,\n          pending: 0,\n          inProgress: 0,\n          completed: 0,\n          byPriority: {\n            low: 0,\n            medium: 0,\n            high: 0,\n            urgent: 0,\n          },\n        };\n      }\n\n      // Get statistics\n      const stats = await this.db\n        .select({\n          total: count(),\n          pending: sql<number>`COUNT(CASE WHEN ${maintenanceRequests.status} = 'pending' THEN 1 END)`,\n          inProgress: sql<number>`COUNT(CASE WHEN ${maintenanceRequests.status} = 'in_progress' THEN 1 END)`,\n          completed: sql<number>`COUNT(CASE WHEN ${maintenanceRequests.status} = 'completed' THEN 1 END)`,\n          low: sql<number>`COUNT(CASE WHEN ${maintenanceRequests.priority} = 'low' THEN 1 END)`,\n          medium: sql<number>`COUNT(CASE WHEN ${maintenanceRequests.priority} = 'medium' THEN 1 END)`,\n          high: sql<number>`COUNT(CASE WHEN ${maintenanceRequests.priority} = 'high' THEN 1 END)`,\n          urgent: sql<number>`COUNT(CASE WHEN ${maintenanceRequests.priority} = 'urgent' THEN 1 END)`,\n        })\n        .from(maintenanceRequests)\n        .where(inArray(maintenanceRequests.propertyId, propertyIds));\n\n      const result = stats[0] || {\n        total: 0,\n        pending: 0,\n        inProgress: 0,\n        completed: 0,\n        low: 0,\n        medium: 0,\n        high: 0,\n        urgent: 0,\n      };\n\n      return {\n        total: result.total,\n        pending: result.pending,\n        inProgress: result.inProgress,\n        completed: result.completed,\n        byPriority: {\n          low: result.low,\n          medium: result.medium,\n          high: result.high,\n          urgent: result.urgent,\n        },\n      };\n    } catch (error) {\n      console.error('Error fetching maintenance stats:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get single maintenance request details\n   */\n  async getMaintenanceRequest(landlordId: string, maintenanceId: string) {\n    try {\n      // Get all properties owned by this landlord\n      const landlordProperties = await this.db\n        .select({ id: properties.id })\n        .from(properties)\n        .where(eq(properties.landlordId, landlordId));\n\n      const propertyIds = landlordProperties.map(p => p.id);\n\n      if (propertyIds.length === 0) {\n        throw new Error('No properties found for this landlord');\n      }\n\n      // Get maintenance request with full details\n      const [request] = await this.db\n        .select({\n          id: maintenanceRequests.id,\n          title: maintenanceRequests.title,\n          description: maintenanceRequests.description,\n          status: maintenanceRequests.status,\n          priority: maintenanceRequests.priority,\n          images: maintenanceRequests.images,\n          comments: maintenanceRequests.comments,\n          createdAt: maintenanceRequests.createdAt,\n          completedAt: maintenanceRequests.completedAt,\n          // Property info\n          propertyId: properties.id,\n          propertyName: properties.name,\n          facilitatorId: properties.facilitatorId,\n          // Unit info\n          unitNumber: sql<string>`unit.unit_number`,\n          // Reporter info\n          reporterFirstName: sql<string>`reporter.first_name`,\n          reporterLastName: sql<string>`reporter.last_name`,\n          reporterRole: sql<string>`reporter.role`,\n          // Assigned facilitator info\n          facilitatorFirstName: sql<string>`facilitator.first_name`,\n          facilitatorLastName: sql<string>`facilitator.last_name`,\n          facilitatorEmail: sql<string>`facilitator.email`,\n        })\n        .from(maintenanceRequests)\n        .innerJoin(properties, eq(maintenanceRequests.propertyId, properties.id))\n        .leftJoin(sql`units AS unit`, sql`unit.property_id = ${maintenanceRequests.propertyId}`)\n        .leftJoin(sql`users AS reporter`, sql`${maintenanceRequests.tenantId} = reporter.id`)\n        .leftJoin(sql`users AS facilitator`, sql`${properties.facilitatorId} = facilitator.id`)\n        .where(and(\n          eq(maintenanceRequests.id, maintenanceId),\n          inArray(maintenanceRequests.propertyId, propertyIds)\n        ));\n\n      if (!request) {\n        throw new Error('Maintenance request not found or access denied');\n      }\n\n      // Parse comments from JSON string if needed\n      let comments = [];\n      try {\n        if (typeof request.comments === 'string') {\n          comments = JSON.parse(request.comments);\n        } else if (Array.isArray(request.comments)) {\n          comments = request.comments;\n        }\n      } catch (e) {\n        console.error('Error parsing comments:', e);\n        comments = [];\n      }\n\n      return {\n        ...request,\n        reportedBy: request.reporterRole === 'landlord' ? 'You (Landlord)' : \n                   request.reporterRole === 'tenant' ? \n                   `${request.reporterFirstName} ${request.reporterLastName} (Tenant)` : 'Unknown',\n        reporterType: request.reporterRole,\n        assignedFacilitator: request.facilitatorFirstName ? \n                           `${request.facilitatorFirstName} ${request.facilitatorLastName}` : 'Not assigned',\n        facilitatorEmail: request.facilitatorEmail,\n        hasFacilitator: !!request.facilitatorId,\n        comments: comments,\n      };\n    } catch (error) {\n      console.error('Error fetching maintenance request:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Report a maintenance issue\n   */\n  async reportMaintenance(\n    landlordId: string,\n    maintenanceData: {\n      propertyId: string;\n      title: string;\n      description: string;\n      priority?: 'low' | 'medium' | 'high' | 'urgent';\n      images?: string[];\n    }\n  ) {\n    try {\n      // Verify property belongs to landlord and get facilitator info\n      const [property] = await this.db\n        .select({\n          id: properties.id,\n          name: properties.name,\n          facilitatorId: properties.facilitatorId,\n          facilitatorFirstName: sql<string>`facilitator.first_name`,\n          facilitatorLastName: sql<string>`facilitator.last_name`,\n        })\n        .from(properties)\n        .leftJoin(sql`users AS facilitator`, sql`${properties.facilitatorId} = facilitator.id`)\n        .where(and(\n          eq(properties.id, maintenanceData.propertyId),\n          eq(properties.landlordId, landlordId)\n        ));\n\n      if (!property) {\n        throw new Error('Property not found or access denied');\n      }\n\n      // Check if property has assigned facilitator\n      if (!property.facilitatorId) {\n        throw new Error('This property does not have an assigned facilitator. Please contact admin to assign a facilitator first.');\n      }\n\n      // Create maintenance request - it will automatically go to the property's facilitator\n      const [newRequest] = await this.db\n        .insert(maintenanceRequests)\n        .values({\n          tenantId: landlordId, // Landlord is reporting, so use their ID as reporter\n          landlordId: landlordId,\n          propertyId: maintenanceData.propertyId,\n          title: maintenanceData.title,\n          description: maintenanceData.description,\n          priority: maintenanceData.priority || 'medium',\n          status: 'pending',\n          images: maintenanceData.images || [],\n          assignedTo: property.facilitatorId, // Automatically assign to property's facilitator\n        })\n        .returning();\n\n      console.log(`✅ Maintenance request created and assigned to facilitator: ${property.facilitatorFirstName} ${property.facilitatorLastName}`);\n\n      return {\n        ...newRequest,\n        assignedFacilitator: `${property.facilitatorFirstName} ${property.facilitatorLastName}`,\n        propertyName: property.name,\n      };\n    } catch (error) {\n      console.error('Error reporting maintenance:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add a comment to a maintenance request\n   */\n  async addMaintenanceComment(landlordId: string, maintenanceId: string, commentText: string) {\n    try {\n      // Get the maintenance request and verify access\n      const [request] = await this.db\n        .select({\n          id: maintenanceRequests.id,\n          propertyId: maintenanceRequests.propertyId,\n          comments: maintenanceRequests.comments,\n        })\n        .from(maintenanceRequests)\n        .innerJoin(properties, eq(maintenanceRequests.propertyId, properties.id))\n        .where(and(\n          eq(maintenanceRequests.id, maintenanceId),\n          eq(properties.landlordId, landlordId)\n        ));\n\n      if (!request) {\n        throw new Error('Maintenance request not found or access denied');\n      }\n\n      // Get landlord info\n      const [landlord] = await this.db\n        .select({\n          firstName: users.firstName,\n          lastName: users.lastName,\n        })\n        .from(users)\n        .where(eq(users.id, landlordId));\n\n      // Create new comment\n      const newComment = {\n        id: crypto.randomUUID(),\n        authorId: landlordId,\n        authorName: `${landlord.firstName} ${landlord.lastName}`,\n        authorRole: 'landlord',\n        text: commentText,\n        createdAt: new Date().toISOString(),\n      };\n\n      // Get existing comments or initialize empty array\n      let existingComments = [];\n      try {\n        if (typeof request.comments === 'string') {\n          existingComments = JSON.parse(request.comments);\n        } else if (Array.isArray(request.comments)) {\n          existingComments = request.comments;\n        }\n      } catch (e) {\n        console.error('Error parsing existing comments:', e);\n        existingComments = [];\n      }\n      \n      const updatedComments = [...existingComments, newComment];\n\n      // Update the maintenance request with new comment\n      await this.db\n        .update(maintenanceRequests)\n        .set({ comments: JSON.stringify(updatedComments) })\n        .where(eq(maintenanceRequests.id, maintenanceId));\n      \n      console.log('✅ Comment added successfully:', newComment.id);\n\n      return newComment;\n    } catch (error) {\n      console.error('Error adding comment:', error);\n      throw error;\n    }\n  }\n}"],"names":["LandlordService","getDashboardData","landlordId","console","log","propertiesData","db","select","from","properties","where","eq","length","propertiesManaged","propertyIds","map","p","id","unitsData","acceptedInvitations","activeTenants","pendingVerification","totalRent","outstandingRent","outstandingRentTenants","fullyOccupied","units","inArray","propertyId","allInvitations","tenantInvitations","filter","invitation","status","pendingInvitations","reduce","sum","rent","parseFloat","monthlyRent","Math","ceil","property","propertyUnits","unit","propertyAcceptedInvitations","inv","paymentStats","upcomingPayments","upcomingPaymentsCombined","rentCollected","calculateRealPaymentStats","activeReports","today","Date","rentCollectedDate","toLocaleDateString","year","month","day","dashboardData","error","generatePaymentSchedulesForExistingTenants","and","existingPayment","payments","tenantInvitationId","limit","success","message","totalMonthlyRent","currentYear","getFullYear","paidPayments","yearStart","yearEnd","paidThisYear","payment","paidDate","amountPaid","rentContracts","tenantRentContracts","nextWeek","setDate","getDate","contract","nextPaymentDue","monthlyAmount","random","stats","getRentContracts","filters","query","tenantId","unitId","expiryDate","landlordPayoutType","transitionStartDate","isExistingTenant","originalExpiryDate","createdAt","updatedAt","tenantFirstName","users","firstName","tenantLastName","lastName","tenantEmail","email","propertyName","name","propertyAddress","address","unitNumber","leftJoin","payoutType","contracts","orderBy","desc","getEscrowBalances","balances","landlordEscrowBalances","contractId","totalEscrowed","monthsAccumulated","expectedReleaseDate","isReleased","releasedAt","releasedAmount","getPaymentHistory","options","page","offset","amount","dueDate","paymentMethod","notes","history","count","totalCount","data","pagination","total","totalPages","getContractStats","contractStats","totalContracts","monthlyPayoutContracts","sql","yearlyPayoutContracts","activeContracts","totalMonthlyRevenue","escrowStats","pendingReleases","escrow","getMaintenanceRequests","landlordProperties","facilitatorId","maintenanceRequests","title","description","priority","images","completedAt","tenantRole","landlordFirstName","landlordLastName","landlordRole","facilitatorFirstName","facilitatorLastName","innerJoin","requests","request","reportedBy","reporterType","assignedFacilitator","hasFacilitator","getMaintenanceStats","pending","inProgress","completed","byPriority","low","medium","high","urgent","result","getMaintenanceRequest","maintenanceId","Error","comments","reporterFirstName","reporterLastName","reporterRole","facilitatorEmail","JSON","parse","Array","isArray","e","reportMaintenance","maintenanceData","newRequest","insert","values","assignedTo","returning","addMaintenanceComment","commentText","landlord","newComment","crypto","randomUUID","authorId","authorName","authorRole","text","toISOString","existingComments","updatedComments","update","set","stringify"],"mappings":"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"}